/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DashReaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/rsvp-view.ts
var import_obsidian = require("obsidian");

// src/rsvp-engine.ts
var RSVPEngine = class {
  constructor(settings, onWordChange, onComplete) {
    this.words = [];
    this.currentIndex = 0;
    this.isPlaying = false;
    this.timer = null;
    this.startTime = 0;
    this.startWpm = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.settings = settings;
    this.onWordChange = onWordChange;
    this.onComplete = onComplete;
  }
  setText(text, startPosition, startWordIndex) {
    console.log("DashReader Engine: setText called with startPosition:", startPosition, "startWordIndex:", startWordIndex);
    const cleaned = text.replace(/\s+/g, " ").replace(/\n+/g, "\n").trim();
    this.words = cleaned.split(/\s+/);
    console.log("DashReader Engine: Total words after split:", this.words.length);
    if (startWordIndex !== void 0) {
      this.currentIndex = Math.max(0, Math.min(startWordIndex, this.words.length - 1));
      console.log("DashReader Engine: Starting at word index", this.currentIndex, "/", this.words.length, "(from startWordIndex)");
    } else if (startPosition !== void 0 && startPosition > 0) {
      const textUpToCursor = text.substring(0, startPosition);
      const wordsBeforeCursor = textUpToCursor.trim().split(/\s+/).length;
      this.currentIndex = Math.min(wordsBeforeCursor, this.words.length - 1);
      console.log("DashReader Engine: Starting at word index", this.currentIndex, "/", this.words.length, "(from startPosition)");
    } else {
      this.currentIndex = 0;
      console.log("DashReader Engine: Starting at beginning (no start position)");
    }
  }
  play() {
    if (this.isPlaying)
      return;
    if (this.currentIndex >= this.words.length) {
      this.currentIndex = 0;
    }
    this.isPlaying = true;
    if (this.startTime === 0) {
      this.startTime = Date.now();
      this.startWpm = this.settings.wpm;
    } else if (this.lastPauseTime > 0) {
      this.pausedTime += Date.now() - this.lastPauseTime;
      this.lastPauseTime = 0;
    }
    this.displayNextWord();
  }
  pause() {
    this.isPlaying = false;
    if (this.timer !== null) {
      window.clearTimeout(this.timer);
      this.timer = null;
    }
    this.lastPauseTime = Date.now();
  }
  stop() {
    this.pause();
    this.currentIndex = 0;
    this.startTime = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.startWpm = 0;
  }
  reset() {
    this.stop();
  }
  rewind(steps = 10) {
    this.currentIndex = Math.max(0, this.currentIndex - steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  forward(steps = 10) {
    this.currentIndex = Math.min(this.words.length - 1, this.currentIndex + steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  displayCurrentWord() {
    if (this.currentIndex >= this.words.length) {
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
  }
  displayNextWord() {
    if (!this.isPlaying || this.currentIndex >= this.words.length) {
      if (this.currentIndex >= this.words.length) {
        this.isPlaying = false;
        this.onComplete();
      }
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
    const delay = this.calculateDelay(chunk.text);
    this.currentIndex += this.settings.chunkSize;
    this.timer = window.setTimeout(() => {
      this.displayNextWord();
    }, delay);
  }
  getChunk(startIndex) {
    const endIndex = Math.min(
      startIndex + this.settings.chunkSize,
      this.words.length
    );
    const chunkWords = this.words.slice(startIndex, endIndex);
    const text = chunkWords.join(" ");
    return {
      text,
      index: startIndex,
      delay: this.calculateDelay(text),
      isEnd: endIndex >= this.words.length
    };
  }
  getCurrentWpm() {
    if (!this.settings.enableAcceleration || this.startTime === 0) {
      return this.settings.wpm;
    }
    const elapsed = (Date.now() - this.startTime - this.pausedTime) / 1e3;
    if (elapsed >= this.settings.accelerationDuration) {
      return this.settings.accelerationTargetWpm;
    }
    const progress = elapsed / this.settings.accelerationDuration;
    const wpmDiff = this.settings.accelerationTargetWpm - this.startWpm;
    const currentWpm = this.startWpm + wpmDiff * progress;
    return Math.round(currentWpm);
  }
  calculateDelay(text) {
    const currentWpm = this.getCurrentWpm();
    const baseDelay = 60 / currentWpm * 1e3;
    if (!this.settings.enableMicropause) {
      return baseDelay;
    }
    let multiplier = 1;
    const trimmedText = text.trim();
    const headingMatch = trimmedText.match(/^\[H(\d)\]/);
    if (headingMatch) {
      const level = parseInt(headingMatch[1]);
      const headingMultipliers = [0, 3, 2.5, 2, 1.8, 1.5, 1.3];
      multiplier *= headingMultipliers[level] || 2;
    }
    if (/^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmedText)) {
      multiplier *= 2;
    }
    if (/^[-*+•]/.test(trimmedText)) {
      multiplier *= 1.8;
    }
    if (/[.!?;:]$/.test(text)) {
      multiplier *= this.settings.micropausePunctuation;
    } else if (/[,]$/.test(text)) {
      multiplier *= Math.max(1, this.settings.micropausePunctuation - 0.3);
    }
    if (text.length > 8) {
      multiplier *= this.settings.micropauseLongWords;
    }
    if (text.includes("\n")) {
      multiplier *= this.settings.micropauseParagraph;
    }
    return baseDelay * multiplier;
  }
  getProgress() {
    return this.words.length > 0 ? this.currentIndex / this.words.length * 100 : 0;
  }
  getCurrentIndex() {
    return this.currentIndex;
  }
  getTotalWords() {
    return this.words.length;
  }
  getIsPlaying() {
    return this.isPlaying;
  }
  setWpm(wpm) {
    this.settings.wpm = Math.max(50, Math.min(1e3, wpm));
  }
  getWpm() {
    return this.settings.wpm;
  }
  setChunkSize(size) {
    this.settings.chunkSize = Math.max(1, Math.min(5, size));
  }
  getChunkSize() {
    return this.settings.chunkSize;
  }
  getContext(contextWords = 3) {
    const beforeStart = Math.max(0, this.currentIndex - contextWords);
    const afterEnd = Math.min(this.words.length, this.currentIndex + this.settings.chunkSize + contextWords);
    return {
      before: this.words.slice(beforeStart, this.currentIndex),
      after: this.words.slice(this.currentIndex + this.settings.chunkSize, afterEnd)
    };
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getEstimatedDuration() {
    if (this.words.length === 0)
      return 0;
    const remainingWords = Math.max(0, this.words.length - this.currentIndex);
    if (remainingWords === 0)
      return 0;
    const averageWpm = this.settings.enableAcceleration ? (this.settings.wpm + this.settings.accelerationTargetWpm) / 2 : this.settings.wpm;
    return this.calculateAccurateRemainingTime(averageWpm);
  }
  calculateAccurateRemainingTime(wpm) {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    let totalTimeMs = 0;
    const baseDelay = 60 / wpm * 1e3;
    for (let i = this.currentIndex; i < this.words.length; i++) {
      const word = this.words[i];
      if (!this.settings.enableMicropause) {
        totalTimeMs += baseDelay;
        continue;
      }
      let multiplier = 1;
      const trimmedText = word.trim();
      const headingMatch = trimmedText.match(/^\[H(\d)\]/);
      if (headingMatch) {
        const level = parseInt(headingMatch[1]);
        const headingMultipliers = [0, 3, 2.5, 2, 1.8, 1.5, 1.3];
        multiplier *= headingMultipliers[level] || 2;
      }
      if (/^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmedText)) {
        multiplier *= 2;
      }
      if (/^[-*+•]/.test(trimmedText)) {
        multiplier *= 1.8;
      }
      if (/[.!?;:]$/.test(word)) {
        multiplier *= this.settings.micropausePunctuation;
      } else if (/[,]$/.test(word)) {
        multiplier *= Math.max(1, this.settings.micropausePunctuation - 0.3);
      }
      if (word.length > 8) {
        multiplier *= this.settings.micropauseLongWords;
      }
      if (word.includes("\n")) {
        multiplier *= this.settings.micropauseParagraph;
      }
      totalTimeMs += baseDelay * multiplier;
    }
    return Math.ceil(totalTimeMs / 1e3);
  }
  getRemainingWords() {
    return Math.max(0, this.words.length - this.currentIndex);
  }
  getElapsedTime() {
    if (this.startTime === 0)
      return 0;
    const now = this.isPlaying ? Date.now() : this.lastPauseTime || Date.now();
    return Math.floor((now - this.startTime - this.pausedTime) / 1e3);
  }
  getRemainingTime() {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    const currentWpm = this.getCurrentWpm();
    return this.calculateAccurateRemainingTime(currentWpm);
  }
  getCurrentWpmPublic() {
    return this.getCurrentWpm();
  }
};

// src/markdown-parser.ts
var MarkdownParser = class {
  static parseToPlainText(markdown) {
    let text = markdown;
    text = text.replace(/^---[\s\S]*?---\n?/m, "");
    text = text.replace(/```[\w-]*\n?([\s\S]*?)```/g, "$1");
    text = text.replace(/`([^`]+)`/g, "$1");
    text = text.replace(/!\[([^\]]*)\]\([^\)]+\)/g, "");
    text = text.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1");
    text = text.replace(/\[\[([^\]|]+)(\|([^\]]+))?\]\]/g, (match, link, pipe, alias) => {
      return alias || link;
    });
    text = text.replace(/\*\*\*([^\*]+)\*\*\*/g, "$1");
    text = text.replace(/\*\*([^\*]+)\*\*/g, "$1");
    text = text.replace(/__([^_]+)__/g, "$1");
    text = text.replace(/\*([^\*\n]+)\*/g, "$1");
    text = text.replace(/_([^_\n]+)_/g, "$1");
    text = text.replace(/~~([^~]+)~~/g, "$1");
    text = text.replace(/==([^=]+)==/g, "$1");
    text = text.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, content) => {
      const level = hashes.length;
      return `[H${level}]${content}`;
    });
    text = text.replace(/^>\s*\[![\w-]+\].*$/gm, "");
    text = text.replace(/^>\s*/gm, "");
    text = text.replace(/^[\s]*[-*+]\s+/gm, "");
    text = text.replace(/^[\s]*\d+\.\s+/gm, "");
    text = text.replace(/^[\s]*[-*_]{3,}[\s]*$/gm, "");
    text = text.replace(/(?:^|\s)(#[a-zA-Z0-9_/-]+)/g, "");
    text = text.replace(/\[\^[^\]]+\]/g, "");
    text = text.replace(/^\[\^[^\]]+\]:.*$/gm, "");
    text = text.replace(/^---\s*Backlinks?\s*---[\s\S]*$/m, "");
    text = text.replace(/^##?\s*Backlinks?[\s\S]*$/m, "");
    text = text.replace(/<!--[\s\S]*?-->/g, "");
    text = text.replace(/<[^>]+>/g, "");
    text = text.replace(/\n{3,}/g, "\n\n");
    text = text.replace(/^[ \t]+/gm, "");
    text = text.replace(/[ \t]+$/gm, "");
    text = text.trim();
    return text;
  }
  /**
   * Parse le texte sélectionné en tenant compte du contexte Obsidian
   */
  static parseSelection(text) {
    return this.parseToPlainText(text);
  }
};

// src/rsvp-view.ts
var VIEW_TYPE_DASHREADER = "dashreader-view";
var DashReaderView = class extends import_obsidian.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.startTime = 0;
    this.wordsRead = 0;
    this.showingControls = false;
    this.showingSettings = false;
    this.settings = settings;
    this.engine = new RSVPEngine(
      settings,
      this.onWordChange.bind(this),
      this.onComplete.bind(this)
    );
  }
  getViewType() {
    return VIEW_TYPE_DASHREADER;
  }
  getDisplayText() {
    return "DashReader";
  }
  getIcon() {
    return "zap";
  }
  async onOpen() {
    this.mainContainerEl = this.contentEl.createDiv({ cls: "dashreader-container" });
    this.buildUI();
    this.setupHotkeys();
    this.app.workspace.onLayoutReady(() => {
      this.setupAutoLoad();
    });
  }
  buildUI() {
    this.toggleBar = this.mainContainerEl.createDiv({ cls: "dashreader-toggle-bar" });
    const toggleControls = this.toggleBar.createEl("button", {
      cls: "dashreader-toggle-btn",
      attr: { title: "Toggle controls (C)" }
    });
    toggleControls.innerHTML = "\u2699\uFE0F";
    toggleControls.addEventListener("click", () => this.toggleControls());
    const toggleStats = this.toggleBar.createEl("button", {
      cls: "dashreader-toggle-btn",
      attr: { title: "Toggle stats (S)" }
    });
    toggleStats.innerHTML = "\u{1F4CA}";
    toggleStats.addEventListener("click", () => this.toggleStats());
    this.statsEl = this.mainContainerEl.createDiv({ cls: "dashreader-stats hidden" });
    this.wpmDisplayEl = this.statsEl.createDiv({ cls: "dashreader-wpm-display" });
    this.wpmDisplayEl.setText(`${this.settings.wpm} WPM`);
    const statsText = this.statsEl.createDiv({ cls: "dashreader-stats-text" });
    statsText.setText("Ready");
    const displayArea = this.mainContainerEl.createDiv({ cls: "dashreader-display" });
    if (this.settings.showContext) {
      this.contextBeforeEl = displayArea.createDiv({ cls: "dashreader-context-before" });
    }
    this.wordEl = displayArea.createDiv({ cls: "dashreader-word" });
    this.wordEl.style.fontSize = `${this.settings.fontSize}px`;
    this.wordEl.style.fontFamily = this.settings.fontFamily;
    this.wordEl.style.color = this.settings.fontColor;
    const welcomeMsg = this.wordEl.createDiv({ cls: "dashreader-welcome" });
    welcomeMsg.innerHTML = `
      <div style="font-size: 20px; color: var(--text-muted); text-align: center;">
        <div style="margin-bottom: 12px;">\u{1F4D6} Select text to start reading</div>
        <div style="font-size: 14px; opacity: 0.7;">or use Cmd+P \u2192 "Read selected text"</div>
      </div>
    `;
    if (this.settings.showContext) {
      this.contextAfterEl = displayArea.createDiv({ cls: "dashreader-context-after" });
    }
    this.progressEl = this.mainContainerEl.createDiv({ cls: "dashreader-progress-container" });
    const progressBar = this.progressEl.createDiv({ cls: "dashreader-progress-bar" });
    progressBar.style.width = "0%";
    progressBar.style.background = this.settings.highlightColor;
    this.controlsEl = this.mainContainerEl.createDiv({ cls: "dashreader-controls hidden" });
    this.buildControls();
    this.settingsEl = this.mainContainerEl.createDiv({ cls: "dashreader-settings hidden" });
    this.buildInlineSettings();
  }
  buildControls() {
    const playControls = this.controlsEl.createDiv({ cls: "dashreader-control-group" });
    this.createButton(playControls, "\u23EE", "Rewind (\u2190)", () => this.engine.rewind());
    this.createButton(playControls, "\u25B6", "Play (Shift+Space)", () => this.togglePlay(), "play-btn");
    this.createButton(playControls, "\u23F8", "Pause (Shift+Space)", () => this.engine.pause(), "pause-btn hidden");
    this.createButton(playControls, "\u23ED", "Forward (\u2192)", () => this.engine.forward());
    this.createButton(playControls, "\u23F9", "Stop (Esc)", () => this.engine.reset());
    const wpmGroup = this.controlsEl.createDiv({ cls: "dashreader-control-group" });
    wpmGroup.createEl("span", { text: "WPM: ", cls: "control-label" });
    this.createButton(wpmGroup, "\u2212", "Decrease WPM (\u2193)", () => this.changeWpm(-25), "small-btn");
    const wpmValue = wpmGroup.createEl("span", { text: String(this.settings.wpm), cls: "wpm-value" });
    this.createButton(wpmGroup, "+", "Increase WPM (\u2191)", () => this.changeWpm(25), "small-btn");
    const wordsGroup = this.controlsEl.createDiv({ cls: "dashreader-control-group" });
    wordsGroup.createEl("span", { text: "Words: ", cls: "control-label" });
    this.createButton(wordsGroup, "\u2212", "Fewer words", () => this.changeChunkSize(-1), "small-btn");
    const chunkValue = wordsGroup.createEl("span", { text: String(this.settings.chunkSize), cls: "chunk-value" });
    this.createButton(wordsGroup, "+", "More words", () => this.changeChunkSize(1), "small-btn");
  }
  buildInlineSettings() {
    const wpmGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    wpmGroup.createEl("span", { text: "Speed (WPM): ", cls: "setting-label" });
    this.createButton(wpmGroup, "\u2212", "Slower (-25)", () => this.changeWpmInline(-25), "small-btn");
    const wpmValue = wpmGroup.createEl("span", { text: String(this.settings.wpm), cls: "wpm-inline-value" });
    this.createButton(wpmGroup, "+", "Faster (+25)", () => this.changeWpmInline(25), "small-btn");
    const accelToggleGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    const accelToggle = accelToggleGroup.createEl("label", { cls: "setting-toggle" });
    const accelCheckbox = accelToggle.createEl("input", { type: "checkbox" });
    accelCheckbox.checked = this.settings.enableAcceleration;
    accelCheckbox.addEventListener("change", () => {
      this.settings.enableAcceleration = accelCheckbox.checked;
      this.engine.updateSettings(this.settings);
      accelDurationGroup.style.display = accelCheckbox.checked ? "flex" : "none";
      accelTargetGroup.style.display = accelCheckbox.checked ? "flex" : "none";
    });
    accelToggle.createEl("span", { text: " Speed Acceleration" });
    const accelDurationGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    accelDurationGroup.createEl("span", { text: "Accel Duration (s): ", cls: "setting-label" });
    this.createButton(accelDurationGroup, "\u2212", "Shorter (-5s)", () => this.changeAccelDuration(-5), "small-btn");
    const accelDurationValue = accelDurationGroup.createEl("span", { text: String(this.settings.accelerationDuration), cls: "accel-duration-value" });
    this.createButton(accelDurationGroup, "+", "Longer (+5s)", () => this.changeAccelDuration(5), "small-btn");
    accelDurationGroup.style.display = this.settings.enableAcceleration ? "flex" : "none";
    const accelTargetGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    accelTargetGroup.createEl("span", { text: "Target WPM: ", cls: "setting-label" });
    this.createButton(accelTargetGroup, "\u2212", "Lower (-25)", () => this.changeAccelTarget(-25), "small-btn");
    const accelTargetValue = accelTargetGroup.createEl("span", { text: String(this.settings.accelerationTargetWpm), cls: "accel-target-value" });
    this.createButton(accelTargetGroup, "+", "Higher (+25)", () => this.changeAccelTarget(25), "small-btn");
    accelTargetGroup.style.display = this.settings.enableAcceleration ? "flex" : "none";
    const fontSizeGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    fontSizeGroup.createEl("span", { text: "Font Size: ", cls: "setting-label" });
    this.createButton(fontSizeGroup, "\u2212", "Smaller", () => this.changeFontSize(-4), "small-btn");
    const fontValue = fontSizeGroup.createEl("span", { text: String(this.settings.fontSize), cls: "font-value" });
    this.createButton(fontSizeGroup, "+", "Larger", () => this.changeFontSize(4), "small-btn");
    const contextGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    const contextToggle = contextGroup.createEl("label", { cls: "setting-toggle" });
    const contextCheckbox = contextToggle.createEl("input", { type: "checkbox" });
    contextCheckbox.checked = this.settings.showContext;
    contextCheckbox.addEventListener("change", () => {
      this.settings.showContext = contextCheckbox.checked;
      this.toggleContextDisplay();
    });
    contextToggle.createEl("span", { text: " Show context" });
    const micropauseGroup = this.settingsEl.createDiv({ cls: "dashreader-setting-group" });
    const micropauseToggle = micropauseGroup.createEl("label", { cls: "setting-toggle" });
    const micropauseCheckbox = micropauseToggle.createEl("input", { type: "checkbox" });
    micropauseCheckbox.checked = this.settings.enableMicropause;
    micropauseCheckbox.addEventListener("change", () => {
      this.settings.enableMicropause = micropauseCheckbox.checked;
      this.engine.updateSettings(this.settings);
    });
    micropauseToggle.createEl("span", { text: " Micropause" });
  }
  createButton(parent, text, title, onClick, className = "") {
    const btn = parent.createEl("button", {
      text,
      cls: `dashreader-btn ${className}`,
      attr: { title }
    });
    btn.addEventListener("click", onClick);
    return btn;
  }
  toggleControls() {
    this.showingControls = !this.showingControls;
    this.controlsEl.toggleClass("hidden", !this.showingControls);
    this.settingsEl.toggleClass("hidden", !this.showingControls);
  }
  toggleStats() {
    this.showingSettings = !this.showingSettings;
    this.statsEl.toggleClass("hidden", !this.showingSettings);
  }
  toggleContextDisplay() {
    if (this.contextBeforeEl) {
      this.contextBeforeEl.style.display = this.settings.showContext ? "block" : "none";
    }
    if (this.contextAfterEl) {
      this.contextAfterEl.style.display = this.settings.showContext ? "block" : "none";
    }
  }
  setupAutoLoad() {
    let lastSelection = "";
    let lastFilePath = "";
    let lastCursorPosition = -1;
    let lastCheckTime = 0;
    const checkSelectionOrCursor = () => {
      const now = Date.now();
      if (now - lastCheckTime < 150) {
        return;
      }
      lastCheckTime = now;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView)
        return;
      const currentFile = this.app.workspace.getActiveFile();
      if (!currentFile)
        return;
      const fileName = currentFile.name;
      if (activeView.editor.somethingSelected()) {
        const selection = activeView.editor.getSelection();
        if (selection && selection.length > 30 && selection !== lastSelection) {
          lastSelection = selection;
          const cursor = activeView.editor.getCursor("from");
          const lineNumber = cursor.line + 1;
          console.log("DashReader: Auto-loading selection", selection.length, "characters from", fileName, "line", lineNumber);
          this.loadText(selection, { fileName, lineNumber });
        }
      } else {
        const fullContent = activeView.editor.getValue();
        if (fullContent && fullContent.trim().length > 50) {
          const cursor = activeView.editor.getCursor();
          const cursorPosition = activeView.editor.posToOffset(cursor);
          if (cursorPosition !== lastCursorPosition) {
            const positionDiff = Math.abs(cursorPosition - lastCursorPosition);
            console.log("DashReader: Cursor moved from", lastCursorPosition, "to", cursorPosition, "(diff:", positionDiff, ")");
            console.log("DashReader: Reloading from cursor position", cursorPosition, "in", fileName);
            this.loadText(fullContent, { fileName, cursorPosition });
            lastSelection = "";
            lastCursorPosition = cursorPosition;
          }
        }
      }
    };
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (!file)
          return;
        lastSelection = "";
        lastFilePath = file.path;
        lastCursorPosition = -1;
        console.log("DashReader: File opened:", file.path);
        setTimeout(() => {
          if (!this.mainContainerEl.isShown())
            return;
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (activeView) {
            const fileName = file.name;
            if (activeView.editor.somethingSelected()) {
              const selection = activeView.editor.getSelection();
              if (selection && selection.length > 30) {
                const cursor = activeView.editor.getCursor("from");
                const lineNumber = cursor.line + 1;
                console.log("DashReader: Auto-loading selection", selection.length, "characters from line", lineNumber);
                this.loadText(selection, { fileName, lineNumber });
                return;
              }
            }
            const fullContent = activeView.editor.getValue();
            if (fullContent && fullContent.trim().length > 50) {
              const cursor = activeView.editor.getCursor();
              const cursorPosition = activeView.editor.posToOffset(cursor);
              console.log("DashReader: Auto-loading entire page from cursor position", cursorPosition);
              this.loadText(fullContent, { fileName, cursorPosition });
            }
          }
        }, 300);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (!this.mainContainerEl || !this.mainContainerEl.isShown()) {
          return;
        }
        console.log("DashReader: Active leaf changed");
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView) {
          const currentFile = this.app.workspace.getActiveFile();
          if (currentFile && currentFile.path !== lastFilePath) {
            lastSelection = "";
            lastFilePath = currentFile.path;
            lastCursorPosition = -1;
            setTimeout(() => {
              if (!this.mainContainerEl.isShown())
                return;
              const fileName = currentFile.name;
              if (activeView.editor.somethingSelected()) {
                const selection = activeView.editor.getSelection();
                if (selection && selection.length > 30) {
                  const cursor = activeView.editor.getCursor("from");
                  const lineNumber = cursor.line + 1;
                  this.loadText(selection, { fileName, lineNumber });
                  return;
                }
              }
              const fullContent = activeView.editor.getValue();
              if (fullContent && fullContent.trim().length > 50) {
                const cursor = activeView.editor.getCursor();
                const cursorPosition = activeView.editor.posToOffset(cursor);
                this.loadText(fullContent, { fileName, cursorPosition });
              }
            }, 200);
          }
        }
      })
    );
    this.registerDomEvent(document, "mouseup", () => {
      console.log("DashReader: Mouse click detected");
      setTimeout(() => {
        if (this.mainContainerEl.isShown()) {
          checkSelectionOrCursor();
        }
      }, 50);
    });
    this.registerDomEvent(document, "keyup", (evt) => {
      const isNavigationKey = (
        // Touches fléchées
        evt.key === "ArrowUp" || evt.key === "ArrowDown" || evt.key === "ArrowLeft" || evt.key === "ArrowRight" || // Home/End/PageUp/PageDown
        evt.key === "Home" || evt.key === "End" || evt.key === "PageUp" || evt.key === "PageDown" || // Enter pour nouvelle ligne
        evt.key === "Enter" || // Vim-style (j/k pour bas/haut)
        evt.key === "j" && evt.ctrlKey || evt.key === "k" && evt.ctrlKey || evt.key === "d" && evt.ctrlKey || evt.key === "u" && evt.ctrlKey || // Cmd/Ctrl + flèches
        (evt.key === "ArrowUp" || evt.key === "ArrowDown") && (evt.metaKey || evt.ctrlKey)
      );
      const isSelectionKey = evt.shiftKey || evt.key === "a" && (evt.metaKey || evt.ctrlKey);
      if (isNavigationKey || isSelectionKey) {
        console.log("DashReader: Navigation key detected:", evt.key, "with modifiers:", {
          shift: evt.shiftKey,
          ctrl: evt.ctrlKey,
          meta: evt.metaKey
        });
        setTimeout(() => {
          if (this.mainContainerEl.isShown()) {
            checkSelectionOrCursor();
          }
        }, 50);
      }
    });
    console.log("DashReader: Auto-load setup complete (with file-open event)");
  }
  setupHotkeys() {
    document.addEventListener("keydown", this.handleKeyPress.bind(this));
  }
  handleKeyPress(e) {
    if (!this.mainContainerEl.isShown())
      return;
    if (e.key === "c" && !this.engine.getIsPlaying()) {
      e.preventDefault();
      this.toggleControls();
      return;
    }
    if (e.key === "s" && !this.engine.getIsPlaying()) {
      e.preventDefault();
      this.toggleStats();
      return;
    }
    const keyCode = e.code || e.key;
    if (keyCode === "Space" && e.shiftKey) {
      e.preventDefault();
      console.log("DashReader: Shift+Space pressed, toggling play");
      this.togglePlay();
      return;
    }
    switch (keyCode) {
      case this.settings.hotkeyRewind:
        e.preventDefault();
        this.engine.rewind();
        break;
      case this.settings.hotkeyForward:
        e.preventDefault();
        this.engine.forward();
        break;
      case this.settings.hotkeyIncrementWpm:
        e.preventDefault();
        this.changeWpm(25);
        break;
      case this.settings.hotkeyDecrementWpm:
        e.preventDefault();
        this.changeWpm(-25);
        break;
      case this.settings.hotkeyQuit:
        e.preventDefault();
        this.engine.stop();
        break;
    }
  }
  togglePlay() {
    if (this.engine.getIsPlaying()) {
      this.engine.pause();
      this.updatePlayButton(false);
    } else {
      if (this.startTime === 0) {
        this.startTime = Date.now();
      }
      this.engine.play();
      this.updatePlayButton(true);
    }
  }
  updatePlayButton(isPlaying) {
    const playBtn = this.controlsEl.querySelector(".play-btn");
    const pauseBtn = this.controlsEl.querySelector(".pause-btn");
    if (playBtn && pauseBtn) {
      playBtn.toggleClass("hidden", isPlaying);
      pauseBtn.toggleClass("hidden", !isPlaying);
    }
  }
  changeWpm(delta) {
    const newWpm = this.engine.getWpm() + delta;
    this.engine.setWpm(newWpm);
    this.settings.wpm = this.engine.getWpm();
    if (this.wpmDisplayEl) {
      this.wpmDisplayEl.setText(`${this.settings.wpm} WPM`);
    }
    const wpmValue = this.controlsEl.querySelector(".wpm-value");
    if (wpmValue) {
      wpmValue.setText(String(this.settings.wpm));
    }
  }
  changeChunkSize(delta) {
    const newSize = this.engine.getChunkSize() + delta;
    this.engine.setChunkSize(newSize);
    this.settings.chunkSize = this.engine.getChunkSize();
    const chunkValue = this.controlsEl.querySelector(".chunk-value");
    if (chunkValue) {
      chunkValue.setText(String(this.settings.chunkSize));
    }
  }
  changeFontSize(delta) {
    this.settings.fontSize = Math.max(20, Math.min(120, this.settings.fontSize + delta));
    this.wordEl.style.fontSize = `${this.settings.fontSize}px`;
    const fontValue = this.settingsEl.querySelector(".font-value");
    if (fontValue) {
      fontValue.setText(String(this.settings.fontSize));
    }
  }
  changeWpmInline(delta) {
    const newWpm = this.engine.getWpm() + delta;
    this.engine.setWpm(newWpm);
    this.settings.wpm = this.engine.getWpm();
    if (this.wpmDisplayEl) {
      this.wpmDisplayEl.setText(`${this.settings.wpm} WPM`);
    }
    const wpmValueControls = this.controlsEl.querySelector(".wpm-value");
    if (wpmValueControls) {
      wpmValueControls.setText(String(this.settings.wpm));
    }
    const wpmValueInline = this.settingsEl.querySelector(".wpm-inline-value");
    if (wpmValueInline) {
      wpmValueInline.setText(String(this.settings.wpm));
    }
  }
  changeAccelDuration(delta) {
    this.settings.accelerationDuration = Math.max(10, Math.min(120, this.settings.accelerationDuration + delta));
    this.engine.updateSettings(this.settings);
    const accelDurationValue = this.settingsEl.querySelector(".accel-duration-value");
    if (accelDurationValue) {
      accelDurationValue.setText(String(this.settings.accelerationDuration));
    }
  }
  changeAccelTarget(delta) {
    this.settings.accelerationTargetWpm = Math.max(50, Math.min(1e3, this.settings.accelerationTargetWpm + delta));
    this.engine.updateSettings(this.settings);
    const accelTargetValue = this.settingsEl.querySelector(".accel-target-value");
    if (accelTargetValue) {
      accelTargetValue.setText(String(this.settings.accelerationTargetWpm));
    }
  }
  onWordChange(chunk) {
    var _a;
    const headingMatch = chunk.text.match(/^\[H(\d)\]/);
    let displayText = chunk.text;
    let headingLevel = 0;
    let showSeparator = false;
    if (headingMatch) {
      headingLevel = parseInt(headingMatch[1]);
      displayText = chunk.text.replace(/^\[H\d\]/, "");
      showSeparator = true;
      console.log("DashReader: Heading detected - Level", headingLevel, "Text:", displayText);
    }
    this.displayWordWithHeading(displayText, headingLevel, showSeparator);
    if (this.settings.showContext && this.contextBeforeEl && this.contextAfterEl) {
      const context = this.engine.getContext(this.settings.contextWords);
      this.contextBeforeEl.setText(context.before.join(" "));
      this.contextAfterEl.setText(context.after.join(" "));
    }
    const progress = this.engine.getProgress();
    const progressBar = (_a = this.progressEl) == null ? void 0 : _a.querySelector(".dashreader-progress-bar");
    if (progressBar) {
      progressBar.style.width = `${progress}%`;
    }
    this.wordsRead++;
    this.updateStats();
  }
  displayWordWithHeading(word, headingLevel, showSeparator = false) {
    let fontSizeMultiplier = 1;
    if (headingLevel > 0) {
      const multipliers = [0, 2, 1.75, 1.5, 1.25, 1.1, 1];
      fontSizeMultiplier = multipliers[headingLevel] || 1;
    }
    const adjustedFontSize = this.settings.fontSize * fontSizeMultiplier;
    const processedWord = this.processWord(word);
    const separator = showSeparator ? `<div style="width: 60%; height: 2px; background: var(--text-muted); opacity: 0.4; margin: 0 auto 20px auto;"></div>` : "";
    this.wordEl.innerHTML = `
      ${separator}
      <div style="font-size: ${adjustedFontSize}px; transition: font-size 0.3s ease; font-weight: ${headingLevel > 0 ? "bold" : "normal"};">
        ${processedWord}
      </div>
    `;
  }
  processWord(word) {
    const cleanWord = word.trim();
    const center = Math.max(Math.floor(cleanWord.length / 2) - 1, 0);
    let result = "";
    for (let i = 0; i < cleanWord.length; i++) {
      if (i === center) {
        result += `<span class="dashreader-highlight" style="color: ${this.settings.highlightColor}">${cleanWord[i]}</span>`;
      } else {
        result += cleanWord[i];
      }
    }
    return result;
  }
  onComplete() {
    var _a;
    this.updatePlayButton(false);
    const statsText = (_a = this.statsEl) == null ? void 0 : _a.querySelector(".dashreader-stats-text");
    if (statsText) {
      statsText.setText("Completed! \u{1F389}");
    }
  }
  updateStats() {
    var _a;
    const statsText = (_a = this.statsEl) == null ? void 0 : _a.querySelector(".dashreader-stats-text");
    if (!statsText)
      return;
    const elapsed = this.engine.getElapsedTime();
    const currentWpm = this.engine.getCurrentWpmPublic();
    const remaining = this.engine.getRemainingTime();
    statsText.setText(
      `${this.wordsRead}/${this.engine.getTotalWords()} words | ${this.formatTime(elapsed)} | ${currentWpm} WPM | ${this.formatTime(remaining)} left`
    );
  }
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  }
  loadText(text, source) {
    var _a;
    console.log("DashReader: loadText called with source:", source);
    if (this.engine.getIsPlaying()) {
      this.engine.stop();
      this.updatePlayButton(false);
      console.log("DashReader: Stopped current reading");
    }
    console.log("DashReader: Parsing markdown, original length:", text.length);
    const plainText = MarkdownParser.parseToPlainText(text);
    console.log("DashReader: After parsing, length:", plainText.length);
    console.log("DashReader: First 100 chars:", plainText.substring(0, 100));
    let wordIndexFromCursor;
    if ((source == null ? void 0 : source.cursorPosition) !== void 0) {
      console.log("DashReader: Cursor position detected:", source.cursorPosition);
      const textUpToCursor = text.substring(0, source.cursorPosition);
      const parsedUpToCursor = MarkdownParser.parseToPlainText(textUpToCursor);
      const wordsBeforeCursor = parsedUpToCursor.trim().split(/\s+/).filter((w) => w.length > 0);
      wordIndexFromCursor = wordsBeforeCursor.length;
      console.log("DashReader: Original text up to cursor:", textUpToCursor.length, "chars");
      console.log("DashReader: Parsed text up to cursor:", parsedUpToCursor.length, "chars");
      console.log("DashReader: Words before cursor (after parsing):", wordsBeforeCursor.slice(0, 10), "...");
      console.log("DashReader: Cursor at character", source.cursorPosition, "\u2192 word index", wordIndexFromCursor, "(in parsed text)");
    } else {
      console.log("DashReader: No cursor position provided");
    }
    if (!plainText || plainText.trim().length < 10) {
      console.log("DashReader: Text too short after parsing");
      return;
    }
    this.engine.setText(plainText, void 0, wordIndexFromCursor);
    this.wordsRead = 0;
    this.startTime = 0;
    const welcomeMsg = this.wordEl.querySelector(".dashreader-welcome");
    if (welcomeMsg) {
      welcomeMsg.remove();
    }
    this.wordEl.innerHTML = "";
    let sourceInfo = "";
    if (source == null ? void 0 : source.fileName) {
      sourceInfo = `<div style="font-size: 14px; opacity: 0.6; margin-bottom: 8px;">
        \u{1F4C4} ${source.fileName}${source.lineNumber ? ` (line ${source.lineNumber})` : ""}
      </div>`;
    }
    const totalWords = this.engine.getTotalWords();
    const remainingWords = this.engine.getRemainingWords();
    const estimatedDuration = this.engine.getEstimatedDuration();
    const durationText = this.formatTime(estimatedDuration);
    const statsText = (_a = this.statsEl) == null ? void 0 : _a.querySelector(".dashreader-stats-text");
    if (statsText) {
      const fileInfo = (source == null ? void 0 : source.fileName) ? ` from ${source.fileName}` : "";
      const wordInfo = wordIndexFromCursor && wordIndexFromCursor > 0 ? `${remainingWords}/${totalWords} words` : `${totalWords} words`;
      statsText.setText(`${wordInfo} loaded${fileInfo} - ~${durationText} - Shift+Space to start`);
    }
    const startInfo = wordIndexFromCursor !== void 0 && wordIndexFromCursor > 0 ? ` <span style="opacity: 0.6;">(starting at word ${wordIndexFromCursor + 1}/${totalWords})</span>` : "";
    console.log("DashReader: Start info display:", startInfo);
    console.log("DashReader: Words to read:", remainingWords, "out of", totalWords);
    this.wordEl.innerHTML = `
      <div style="font-size: 18px; color: var(--text-muted); text-align: center;">
        ${sourceInfo}
        Ready to read ${remainingWords} words${startInfo}<br/>
        <span style="font-size: 14px; opacity: 0.7;">Estimated time: ~${durationText}</span><br/>
        <span style="font-size: 14px; opacity: 0.7;">Press Shift+Space to start</span>
      </div>
    `;
    if (this.settings.autoStart) {
      setTimeout(() => {
        this.engine.play();
        this.updatePlayButton(true);
        this.startTime = Date.now();
      }, this.settings.autoStartDelay * 1e3);
    }
  }
  updateSettings(settings) {
    this.settings = settings;
    this.engine.updateSettings(settings);
    if (this.wordEl) {
      this.wordEl.style.fontSize = `${settings.fontSize}px`;
      this.wordEl.style.fontFamily = settings.fontFamily;
      this.wordEl.style.color = settings.fontColor;
    }
    if (this.wpmDisplayEl) {
      this.wpmDisplayEl.setText(`${settings.wpm} WPM`);
    }
  }
  async onClose() {
    this.engine.stop();
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DashReaderSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "DashReader Settings" });
    containerEl.createEl("h3", { text: "Reading Settings" });
    new import_obsidian2.Setting(containerEl).setName("Words per minute (WPM)").setDesc("Reading speed (50-1000)").addSlider((slider) => slider.setLimits(50, 1e3, 25).setValue(this.plugin.settings.wpm).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.wpm = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Words at a time").setDesc("Number of words displayed simultaneously (1-5)").addSlider((slider) => slider.setLimits(1, 5, 1).setValue(this.plugin.settings.chunkSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chunkSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Font size").setDesc("Font size in pixels (20-120px)").addSlider((slider) => slider.setLimits(20, 120, 4).setValue(this.plugin.settings.fontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.fontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Font family").setDesc("Font family for text display").addDropdown((dropdown) => dropdown.addOption("inherit", "Default").addOption("monospace", "Monospace").addOption("serif", "Serif").addOption("sans-serif", "Sans-serif").setValue(this.plugin.settings.fontFamily).onChange(async (value) => {
      this.plugin.settings.fontFamily = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Speed Acceleration" });
    new import_obsidian2.Setting(containerEl).setName("Enable acceleration").setDesc("Gradually increase reading speed over time").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAcceleration).onChange(async (value) => {
      this.plugin.settings.enableAcceleration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Acceleration duration").setDesc("Duration to reach target speed (seconds)").addSlider((slider) => slider.setLimits(10, 120, 5).setValue(this.plugin.settings.accelerationDuration).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.accelerationDuration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Target WPM").setDesc("Target reading speed to reach (50-1000)").addSlider((slider) => slider.setLimits(50, 1e3, 25).setValue(this.plugin.settings.accelerationTargetWpm).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.accelerationTargetWpm = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian2.Setting(containerEl).setName("Highlight color").setDesc("Color for the center character highlight").addText((text) => text.setPlaceholder("#4a9eff").setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
      this.plugin.settings.highlightColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Font color").setDesc("Text color").addText((text) => text.setPlaceholder("#ffffff").setValue(this.plugin.settings.fontColor).onChange(async (value) => {
      this.plugin.settings.fontColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Background color").setDesc("Background color").addText((text) => text.setPlaceholder("#1e1e1e").setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
      this.plugin.settings.backgroundColor = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Context Display" });
    new import_obsidian2.Setting(containerEl).setName("Show context").setDesc("Display words before and after current word").addToggle((toggle) => toggle.setValue(this.plugin.settings.showContext).onChange(async (value) => {
      this.plugin.settings.showContext = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Context words").setDesc("Number of context words to display (1-10)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWords).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.contextWords = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Micropause" });
    new import_obsidian2.Setting(containerEl).setName("Enable micropause").setDesc("Automatic pauses based on punctuation and word length").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMicropause).onChange(async (value) => {
      this.plugin.settings.enableMicropause = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Punctuation pause").setDesc("Pause multiplier for punctuation (1.0-3.0)").addSlider((slider) => slider.setLimits(1, 3, 0.1).setValue(this.plugin.settings.micropausePunctuation).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropausePunctuation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Long words pause").setDesc("Pause multiplier for long words (1.0-2.0)").addSlider((slider) => slider.setLimits(1, 2, 0.1).setValue(this.plugin.settings.micropauseLongWords).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropauseLongWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Paragraph pause").setDesc("Pause multiplier for paragraph breaks (1.0-5.0)").addSlider((slider) => slider.setLimits(1, 5, 0.5).setValue(this.plugin.settings.micropauseParagraph).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropauseParagraph = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto-start" });
    new import_obsidian2.Setting(containerEl).setName("Auto-start reading").setDesc("Automatically start reading after text loads").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStart).onChange(async (value) => {
      this.plugin.settings.autoStart = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto-start delay").setDesc("Delay before auto-start (seconds)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.autoStartDelay).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autoStartDelay = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Display Options" });
    new import_obsidian2.Setting(containerEl).setName("Show progress bar").setDesc("Display reading progress bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showProgress).onChange(async (value) => {
      this.plugin.settings.showProgress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show statistics").setDesc("Display reading statistics").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStats).onChange(async (value) => {
      this.plugin.settings.showStats = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Keyboard Shortcuts" });
    containerEl.createEl("p", {
      text: "Note: Hotkey customization is available in Obsidian's Hotkeys settings.",
      cls: "setting-item-description"
    });
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  wpm: 300,
  chunkSize: 1,
  fontSize: 48,
  highlightColor: "#4a9eff",
  backgroundColor: "#1e1e1e",
  fontColor: "#ffffff",
  fontFamily: "inherit",
  showContext: true,
  contextWords: 3,
  enableMicropause: true,
  micropausePunctuation: 1.5,
  micropauseLongWords: 1.3,
  micropauseParagraph: 2,
  autoStart: false,
  autoStartDelay: 3,
  showProgress: true,
  showStats: true,
  hotkeyPlay: "Space",
  hotkeyRewind: "ArrowLeft",
  hotkeyForward: "ArrowRight",
  hotkeyIncrementWpm: "ArrowUp",
  hotkeyDecrementWpm: "ArrowDown",
  hotkeyQuit: "Escape",
  enableAcceleration: false,
  accelerationDuration: 30,
  accelerationTargetWpm: 450
};

// main.ts
var DashReaderPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
  }
  async onload() {
    console.log("Loading DashReader plugin");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_DASHREADER,
      (leaf) => {
        this.view = new DashReaderView(leaf, this.settings);
        return this.view;
      }
    );
    this.addRibbonIcon("zap", "Open DashReader", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-dashreader",
      name: "Open DashReader",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "read-selection",
      name: "Read selected text",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.activateView().then(() => {
            if (this.view) {
              this.view.loadText(selection);
            }
          });
        } else {
          new import_obsidian3.Notice("Please select some text first");
        }
      }
    });
    this.addCommand({
      id: "read-note",
      name: "Read entire note",
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeView) {
          const content = activeView.editor.getValue();
          this.activateView().then(() => {
            if (this.view) {
              this.view.loadText(content);
            }
          });
        } else {
          new import_obsidian3.Notice("No active note found");
        }
      }
    });
    this.addCommand({
      id: "toggle-play-pause",
      name: "Toggle Play/Pause",
      callback: () => {
        new import_obsidian3.Notice("Use Shift+Space key when DashReader is active");
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Read with DashReader").setIcon("zap").onClick(() => {
              this.activateView().then(() => {
                if (this.view) {
                  this.view.loadText(selection);
                }
              });
            });
          });
        }
      })
    );
    this.addSettingTab(new DashReaderSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.view) {
          this.view.updateSettings(this.settings);
        }
      })
    );
    console.log("DashReader plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading DashReader plugin");
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_DASHREADER);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.view) {
      this.view.updateSettings(this.settings);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_DASHREADER);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_DASHREADER,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      this.view = leaf.view;
    }
  }
};
