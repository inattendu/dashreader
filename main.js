/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DashReaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/rsvp-view.ts
var import_obsidian2 = require("obsidian");

// src/rsvp-engine.ts
var RSVPEngine = class {
  constructor(settings, onWordChange, onComplete) {
    this.words = [];
    this.currentIndex = 0;
    this.isPlaying = false;
    this.timer = null;
    this.startTime = 0;
    this.startWpm = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.headings = [];
    this.wordsReadInSession = 0;
    this.settings = settings;
    this.onWordChange = onWordChange;
    this.onComplete = onComplete;
  }
  setText(text, startPosition, startWordIndex) {
    console.log("DashReader Engine: setText called with startPosition:", startPosition, "startWordIndex:", startWordIndex);
    const cleaned = text.replace(/\s+/g, " ").replace(/\n+/g, "\n").trim();
    this.words = cleaned.split(/\s+/);
    console.log("DashReader Engine: Total words after split:", this.words.length);
    this.extractHeadings();
    console.log("DashReader Engine: Extracted", this.headings.length, "headings");
    if (startWordIndex !== void 0) {
      this.currentIndex = Math.max(0, Math.min(startWordIndex, this.words.length - 1));
      console.log("DashReader Engine: Starting at word index", this.currentIndex, "/", this.words.length, "(from startWordIndex)");
    } else if (startPosition !== void 0 && startPosition > 0) {
      const textUpToCursor = text.substring(0, startPosition);
      const wordsBeforeCursor = textUpToCursor.trim().split(/\s+/).length;
      this.currentIndex = Math.min(wordsBeforeCursor, this.words.length - 1);
      console.log("DashReader Engine: Starting at word index", this.currentIndex, "/", this.words.length, "(from startPosition)");
    } else {
      this.currentIndex = 0;
      console.log("DashReader Engine: Starting at beginning (no start position)");
    }
  }
  play() {
    if (this.isPlaying)
      return;
    if (this.currentIndex >= this.words.length) {
      this.currentIndex = 0;
    }
    this.isPlaying = true;
    if (this.startTime === 0) {
      this.startTime = Date.now();
      this.startWpm = this.settings.wpm;
      this.wordsReadInSession = 0;
    } else if (this.lastPauseTime > 0) {
      this.pausedTime += Date.now() - this.lastPauseTime;
      this.lastPauseTime = 0;
    }
    this.displayNextWord();
  }
  pause() {
    this.isPlaying = false;
    if (this.timer !== null) {
      window.clearTimeout(this.timer);
      this.timer = null;
    }
    this.lastPauseTime = Date.now();
  }
  stop() {
    this.pause();
    this.currentIndex = 0;
    this.startTime = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.startWpm = 0;
    this.wordsReadInSession = 0;
  }
  reset() {
    this.stop();
  }
  rewind(steps = 10) {
    this.currentIndex = Math.max(0, this.currentIndex - steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  forward(steps = 10) {
    this.currentIndex = Math.min(this.words.length - 1, this.currentIndex + steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  displayCurrentWord() {
    if (this.currentIndex >= this.words.length) {
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
  }
  displayNextWord() {
    if (!this.isPlaying || this.currentIndex >= this.words.length) {
      if (this.currentIndex >= this.words.length) {
        this.isPlaying = false;
        this.onComplete();
      }
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
    let delay = this.calculateDelay(chunk.text);
    const SLOW_START_WORDS = 5;
    if (this.wordsReadInSession < SLOW_START_WORDS) {
      const remainingSlowWords = SLOW_START_WORDS - this.wordsReadInSession;
      const slowStartMultiplier = 1 + remainingSlowWords / SLOW_START_WORDS;
      delay *= slowStartMultiplier;
    }
    this.wordsReadInSession++;
    this.currentIndex += this.settings.chunkSize;
    this.timer = window.setTimeout(() => {
      this.displayNextWord();
    }, delay);
  }
  getChunk(startIndex) {
    const endIndex = Math.min(
      startIndex + this.settings.chunkSize,
      this.words.length
    );
    const chunkWords = this.words.slice(startIndex, endIndex);
    const text = chunkWords.join(" ");
    return {
      text,
      index: startIndex,
      delay: this.calculateDelay(text),
      isEnd: endIndex >= this.words.length,
      headingContext: this.getCurrentHeadingContext(startIndex)
    };
  }
  getCurrentWpm() {
    if (!this.settings.enableAcceleration || this.startTime === 0) {
      return this.settings.wpm;
    }
    const elapsed = (Date.now() - this.startTime - this.pausedTime) / 1e3;
    if (elapsed >= this.settings.accelerationDuration) {
      return this.settings.accelerationTargetWpm;
    }
    const progress = elapsed / this.settings.accelerationDuration;
    const wpmDiff = this.settings.accelerationTargetWpm - this.startWpm;
    const currentWpm = this.startWpm + wpmDiff * progress;
    return Math.round(currentWpm);
  }
  calculateDelay(text) {
    const currentWpm = this.getCurrentWpm();
    const baseDelay = 60 / currentWpm * 1e3;
    if (!this.settings.enableMicropause) {
      return baseDelay;
    }
    let multiplier = 1;
    const trimmedText = text.trim();
    const headingMatch = trimmedText.match(/^\[H(\d)\]/);
    if (headingMatch) {
      const level = parseInt(headingMatch[1]);
      const headingMultipliers = [0, 3, 2.5, 2, 1.8, 1.5, 1.3];
      multiplier *= headingMultipliers[level] || 2;
    }
    const calloutMatch = trimmedText.match(/^\[CALLOUT:[\w-]+\]/);
    if (calloutMatch) {
      multiplier *= 2;
    }
    if (/^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmedText)) {
      multiplier *= 2;
    }
    if (/^[-*+•]/.test(trimmedText)) {
      multiplier *= 1.8;
    }
    if (/[.!?]$/.test(text)) {
      multiplier *= this.settings.micropausePunctuation;
    } else if (/[;:,]$/.test(text)) {
      multiplier *= 1.5;
    }
    if (/\d/.test(text)) {
      multiplier *= 1.8;
    }
    if (text.length > 8) {
      multiplier *= this.settings.micropauseLongWords;
    }
    if (text.includes("\n")) {
      multiplier *= this.settings.micropauseParagraph;
    }
    return baseDelay * multiplier;
  }
  /**
   * Extract all headings and callouts from the words array
   * Headings are marked with [H1], [H2], etc.
   * Callouts are marked with [CALLOUT:type] by the markdown parser
   */
  extractHeadings() {
    this.headings = [];
    for (let i = 0; i < this.words.length; i++) {
      const word = this.words[i];
      const headingMatch = word.match(/^\[H(\d)\](.+)/);
      if (headingMatch) {
        const level = parseInt(headingMatch[1]);
        const text = headingMatch[2];
        this.headings.push({
          level,
          text,
          wordIndex: i
        });
        continue;
      }
      const calloutMatch = word.match(/^\[CALLOUT:([\w-]+)\](.+)/);
      if (calloutMatch) {
        const calloutType = calloutMatch[1];
        const text = calloutMatch[2];
        this.headings.push({
          level: 0,
          // Special level for callouts
          text,
          wordIndex: i,
          calloutType
        });
      }
    }
  }
  /**
   * Get the current heading context (breadcrumb) for a given word index
   * Returns the hierarchical path of headings leading to the current position
   */
  getCurrentHeadingContext(wordIndex) {
    if (this.headings.length === 0) {
      return { breadcrumb: [], current: null };
    }
    const relevantHeadings = this.headings.filter((h) => h.wordIndex <= wordIndex);
    if (relevantHeadings.length === 0) {
      return { breadcrumb: [], current: null };
    }
    const breadcrumb = [];
    let currentLevel = 0;
    for (const heading of relevantHeadings) {
      if (heading.level <= currentLevel) {
        while (breadcrumb.length > 0 && breadcrumb[breadcrumb.length - 1].level >= heading.level) {
          breadcrumb.pop();
        }
      }
      breadcrumb.push(heading);
      currentLevel = heading.level;
    }
    return {
      breadcrumb,
      current: breadcrumb[breadcrumb.length - 1] || null
    };
  }
  getProgress() {
    return this.words.length > 0 ? this.currentIndex / this.words.length * 100 : 0;
  }
  getCurrentIndex() {
    return this.currentIndex;
  }
  getTotalWords() {
    return this.words.length;
  }
  getIsPlaying() {
    return this.isPlaying;
  }
  setWpm(wpm) {
    this.settings.wpm = Math.max(50, Math.min(1e3, wpm));
  }
  getWpm() {
    return this.settings.wpm;
  }
  setChunkSize(size) {
    this.settings.chunkSize = Math.max(1, Math.min(5, size));
  }
  getChunkSize() {
    return this.settings.chunkSize;
  }
  getContext(contextWords = 3) {
    const beforeStart = Math.max(0, this.currentIndex - contextWords);
    const afterEnd = Math.min(this.words.length, this.currentIndex + this.settings.chunkSize + contextWords);
    return {
      before: this.words.slice(beforeStart, this.currentIndex),
      after: this.words.slice(this.currentIndex + this.settings.chunkSize, afterEnd)
    };
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getEstimatedDuration() {
    if (this.words.length === 0)
      return 0;
    const remainingWords = Math.max(0, this.words.length - this.currentIndex);
    if (remainingWords === 0)
      return 0;
    const averageWpm = this.settings.enableAcceleration ? (this.settings.wpm + this.settings.accelerationTargetWpm) / 2 : this.settings.wpm;
    return this.calculateAccurateRemainingTime(averageWpm);
  }
  calculateAccurateRemainingTime(wpm) {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    let totalTimeMs = 0;
    const baseDelay = 60 / wpm * 1e3;
    for (let i = this.currentIndex; i < this.words.length; i++) {
      const word = this.words[i];
      if (!this.settings.enableMicropause) {
        totalTimeMs += baseDelay;
        continue;
      }
      let multiplier = 1;
      const trimmedText = word.trim();
      const headingMatch = trimmedText.match(/^\[H(\d)\]/);
      if (headingMatch) {
        const level = parseInt(headingMatch[1]);
        const headingMultipliers = [0, 3, 2.5, 2, 1.8, 1.5, 1.3];
        multiplier *= headingMultipliers[level] || 2;
      }
      const calloutMatch = trimmedText.match(/^\[CALLOUT:[\w-]+\]/);
      if (calloutMatch) {
        multiplier *= 2;
      }
      if (/^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmedText)) {
        multiplier *= 2;
      }
      if (/^[-*+•]/.test(trimmedText)) {
        multiplier *= 1.8;
      }
      if (/[.!?]$/.test(word)) {
        multiplier *= this.settings.micropausePunctuation;
      } else if (/[;:,]$/.test(word)) {
        multiplier *= 1.5;
      }
      if (/\d/.test(word)) {
        multiplier *= 1.8;
      }
      if (word.length > 8) {
        multiplier *= this.settings.micropauseLongWords;
      }
      if (word.includes("\n")) {
        multiplier *= this.settings.micropauseParagraph;
      }
      totalTimeMs += baseDelay * multiplier;
    }
    return Math.ceil(totalTimeMs / 1e3);
  }
  getRemainingWords() {
    return Math.max(0, this.words.length - this.currentIndex);
  }
  getElapsedTime() {
    if (this.startTime === 0)
      return 0;
    const now = this.isPlaying ? Date.now() : this.lastPauseTime || Date.now();
    return Math.floor((now - this.startTime - this.pausedTime) / 1e3);
  }
  getRemainingTime() {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    const currentWpm = this.getCurrentWpm();
    return this.calculateAccurateRemainingTime(currentWpm);
  }
  getCurrentWpmPublic() {
    return this.getCurrentWpm();
  }
};

// src/markdown-parser.ts
var MarkdownParser = class {
  static parseToPlainText(markdown) {
    let text = markdown;
    text = text.replace(/^---[\s\S]*?---\n?/m, "");
    text = text.replace(/```[\w-]*\n?([\s\S]*?)```/g, "$1");
    text = text.replace(/`([^`]+)`/g, "$1");
    text = text.replace(/!\[([^\]]*)\]\([^\)]+\)/g, "");
    text = text.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1");
    text = text.replace(/\[\[([^\]|]+)(\|([^\]]+))?\]\]/g, (match, link, pipe, alias) => {
      return alias || link;
    });
    text = text.replace(/\*\*\*([^\*]+)\*\*\*/g, "$1");
    text = text.replace(/\*\*([^\*]+)\*\*/g, "$1");
    text = text.replace(/__([^_]+)__/g, "$1");
    text = text.replace(/\*([^\*\n]+)\*/g, "$1");
    text = text.replace(/_([^_\n]+)_/g, "$1");
    text = text.replace(/~~([^~]+)~~/g, "$1");
    text = text.replace(/==([^=]+)==/g, "$1");
    text = text.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, content) => {
      const level = hashes.length;
      return `[H${level}]${content}`;
    });
    text = text.replace(/^>\s*\[!([\w-]+)\]\s*(.*)$/gm, (match, type, title) => {
      const displayTitle = title.trim() || type;
      return `[CALLOUT:${type}]${displayTitle}`;
    });
    text = text.replace(/^>\s*/gm, "");
    text = text.replace(/^[\s]*[-*+]\s+/gm, "");
    text = text.replace(/^[\s]*\d+\.\s+/gm, "");
    text = text.replace(/^[\s]*[-*_]{3,}[\s]*$/gm, "");
    text = text.replace(/(?:^|\s)(#[a-zA-Z0-9_/-]+)/g, "");
    text = text.replace(/\[\^[^\]]+\]/g, "");
    text = text.replace(/^\[\^[^\]]+\]:.*$/gm, "");
    text = text.replace(/^---\s*Backlinks?\s*---[\s\S]*$/m, "");
    text = text.replace(/^##?\s*Backlinks?[\s\S]*$/m, "");
    text = text.replace(/<!--[\s\S]*?-->/g, "");
    text = text.replace(/<[^>]+>/g, "");
    text = text.replace(/\n{3,}/g, "\n\n");
    text = text.replace(/^[ \t]+/gm, "");
    text = text.replace(/[ \t]+$/gm, "");
    text = text.trim();
    return text;
  }
  /**
   * Parse le texte sélectionné en tenant compte du contexte Obsidian
   */
  static parseSelection(text) {
    return this.parseToPlainText(text);
  }
};

// src/view-state.ts
var DEFAULT_VIEW_STATE = {
  wordsRead: 0,
  startTime: 0,
  showingControls: false,
  showingSettings: false,
  showingStats: false,
  currentWpm: 0,
  currentChunkSize: 0,
  currentFontSize: 0,
  isLoading: false
};
var ViewState = class {
  /**
   * Creates a new ViewState instance
   *
   * @param initialState - Optional partial state to merge with defaults
   *
   * @example
   * ```typescript
   * // Default state
   * const state = new ViewState();
   *
   * // With initial values
   * const state = new ViewState({
   *   currentWpm: 300,
   *   showingControls: true
   * });
   * ```
   */
  constructor(initialState = {}) {
    this.listeners = /* @__PURE__ */ new Set();
    this.state = { ...DEFAULT_VIEW_STATE, ...initialState };
  }
  /**
   * Get a state value (type-safe)
   *
   * Uses TypeScript generics to ensure return type matches the requested key.
   *
   * @param key - State property to get
   * @returns Current value of the property
   *
   * @example
   * ```typescript
   * const wpm: number = state.get('currentWpm');
   * const showing: boolean = state.get('showingControls');
   * ```
   */
  get(key) {
    return this.state[key];
  }
  /**
   * Set a state value and notify listeners (type-safe)
   *
   * Updates the state property and notifies all subscribers if the value changed.
   * Automatically skips notification if the new value equals the old value.
   *
   * @param key - State property to set
   * @param value - New value for the property
   *
   * @example
   * ```typescript
   * state.set('currentWpm', 350);
   * state.set('showingControls', true);
   * state.set('loadedFileName', 'My Note.md');
   * ```
   */
  set(key, value) {
    const oldValue = this.state[key];
    if (oldValue === value)
      return;
    this.state[key] = value;
    this.notify(key, value, oldValue);
  }
  /**
   * Update multiple state values at once (batch update)
   *
   * Efficiently updates multiple properties in a single call. Each changed
   * property will trigger its own notification to listeners.
   *
   * @param updates - Partial state object with properties to update
   *
   * @example
   * ```typescript
   * state.update({
   *   currentWpm: 350,
   *   showingControls: true,
   *   wordsRead: 42
   * });
   * ```
   */
  update(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  /**
   * Reset all state to default values
   *
   * Sets every state property back to its default value from DEFAULT_VIEW_STATE.
   * Each reset property triggers a notification to listeners.
   *
   * @example
   * ```typescript
   * // After reading session, reset to defaults
   * state.reset();
   * ```
   */
  reset() {
    Object.entries(DEFAULT_VIEW_STATE).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  /**
   * Subscribe to state changes (observer pattern)
   *
   * Registers a listener function that will be called whenever any state
   * property changes. Returns an unsubscribe function for cleanup.
   *
   * **Error Handling**: Listener errors are caught and logged to prevent
   * one broken listener from breaking all listeners.
   *
   * @param listener - Callback function to call on state changes
   * @returns Unsubscribe function to remove the listener
   *
   * @example
   * ```typescript
   * // Subscribe and get unsubscribe function
   * const unsubscribe = state.subscribe((key, value, oldValue) => {
   *   if (key === 'currentWpm') {
   *     console.log(`WPM changed from ${oldValue} to ${value}`);
   *   }
   * });
   *
   * // Later, cleanup
   * unsubscribe();
   * ```
   */
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  /**
   * Notify all listeners of a state change (internal)
   *
   * Calls each registered listener with the changed property details.
   * Catches and logs errors to prevent one broken listener from affecting others.
   *
   * @param key - Name of the property that changed
   * @param value - New value of the property
   * @param oldValue - Previous value of the property
   *
   * @private
   */
  notify(key, value, oldValue) {
    this.listeners.forEach((listener) => {
      try {
        listener(key, value, oldValue);
      } catch (error) {
        console.error("DashReader: Error in state listener", error);
      }
    });
  }
  /**
   * Get all state as a plain object (for debugging)
   *
   * Returns a shallow copy of the entire state object. Useful for logging
   * or debugging state issues.
   *
   * @returns Readonly copy of the full state
   *
   * @example
   * ```typescript
   * console.log('Current state:', state.getAll());
   * // Output: { wordsRead: 42, currentWpm: 350, showingControls: true, ... }
   * ```
   */
  getAll() {
    return { ...this.state };
  }
  /**
   * Toggle a boolean state value (helper)
   *
   * Convenience method for toggling boolean properties. Flips the value
   * from true to false or false to true.
   *
   * @param key - Boolean property to toggle (showingControls, showingSettings, showingStats, isLoading)
   *
   * @example
   * ```typescript
   * // Toggle control panel visibility
   * state.toggle('showingControls');
   *
   * // Toggle settings panel
   * state.toggle('showingSettings');
   * ```
   */
  toggle(key) {
    const currentValue = this.get(key);
    if (typeof currentValue === "boolean") {
      this.set(key, !currentValue);
    }
  }
  /**
   * Increment a numeric state value (helper)
   *
   * Convenience method for incrementing numeric properties. Can add positive
   * or negative deltas.
   *
   * @param key - Numeric property to increment (currently only wordsRead)
   * @param delta - Amount to add (default: 1, can be negative)
   *
   * @example
   * ```typescript
   * // Increment words read by 1
   * state.increment('wordsRead');
   *
   * // Increment by 5
   * state.increment('wordsRead', 5);
   *
   * // Decrement by 1
   * state.increment('wordsRead', -1);
   * ```
   */
  increment(key, delta = 1) {
    const currentValue = this.get(key);
    if (typeof currentValue === "number") {
      this.set(key, currentValue + delta);
    }
  }
};

// src/constants.ts
var CSS_CLASSES = {
  // Main container
  container: "dashreader-container",
  // Toggle bar
  toggleBar: "dashreader-toggle-bar",
  toggleBtn: "dashreader-toggle-btn",
  // Display area
  display: "dashreader-display",
  word: "dashreader-word",
  welcome: "dashreader-welcome",
  highlight: "dashreader-highlight",
  // Context
  contextBefore: "dashreader-context-before",
  contextAfter: "dashreader-context-after",
  // Progress
  progressContainer: "dashreader-progress-container",
  progressBar: "dashreader-progress-bar",
  // Controls
  controls: "dashreader-controls",
  controlGroup: "dashreader-control-group",
  controlLabel: "control-label",
  // Settings
  settings: "dashreader-settings",
  settingGroup: "dashreader-setting-group",
  settingLabel: "setting-label",
  settingToggle: "setting-toggle",
  // Stats
  stats: "dashreader-stats",
  statsText: "dashreader-stats-text",
  wpmDisplay: "dashreader-wpm-display",
  // Buttons
  btn: "dashreader-btn",
  playBtn: "play-btn",
  pauseBtn: "pause-btn",
  smallBtn: "small-btn",
  // Value displays
  wpmValue: "wpm-value",
  wpmInlineValue: "wpm-inline-value",
  chunkValue: "chunk-value",
  fontValue: "font-value",
  accelDurationValue: "accel-duration-value",
  accelTargetValue: "accel-target-value",
  // State classes
  hidden: "hidden"
};
var TIMING = {
  /** Delay before auto-loading content from editor (file-open event) */
  autoLoadDelay: 300,
  /** Shorter delay for leaf-change events (editor already active) */
  autoLoadDelayShort: 200,
  /** Very short delay for immediate operations */
  autoLoadDelayVeryShort: 50,
  /** Throttle interval for cursor/selection checks (prevents excessive checks) */
  throttleDelay: 150,
  /** CSS transition duration for smooth animations */
  transitionDuration: 300
};
var TEXT_LIMITS = {
  /** Minimum characters in selection to trigger auto-load */
  minSelectionLength: 30,
  /** Minimum characters in full document to load */
  minContentLength: 50,
  /** Minimum words in parsed text to display */
  minParsedLength: 10
};
var INCREMENTS = {
  /** WPM increment (25 = noticeable speed change) */
  wpm: 25,
  /** Chunk size increment (1 word at a time) */
  chunkSize: 1,
  /** Font size increment in pixels (4px = visible change) */
  fontSize: 4,
  /** Acceleration duration increment in seconds */
  accelDuration: 5
};
var LIMITS = {
  /** Font size range in pixels (20 = readable minimum, 120 = fills viewport) */
  fontSize: { min: 20, max: 120 },
  /** WPM range (50 = very slow, 1000 = speed reading limit) */
  wpm: { min: 50, max: 1e3 },
  /** Acceleration duration in seconds (10 = quick ramp, 120 = gradual) */
  accelDuration: { min: 10, max: 120 }
};
var ICONS = {
  /** Rewind to start button */
  rewind: "\u23EE",
  /** Play button */
  play: "\u25B6",
  /** Pause button */
  pause: "\u23F8",
  /** Skip forward button */
  forward: "\u23ED",
  /** Stop button */
  stop: "\u23F9",
  /** Increment (+) button */
  increment: "+",
  /** Decrement (−) button (using minus sign, not hyphen) */
  decrement: "\u2212",
  /** Settings toggle button */
  settings: "\u2699\uFE0F",
  /** Statistics toggle button */
  stats: "\u{1F4CA}",
  /** File/document indicator */
  file: "\u{1F4C4}",
  /** Celebration (reading complete) */
  celebration: "\u{1F389}",
  /** Book/reading indicator */
  book: "\u{1F4D6}"
};
var HEADING_MULTIPLIERS = {
  /** H1 heading multiplier (2x base font = major section) */
  h1: 2,
  /** H2 heading multiplier (1.75x base font) */
  h2: 1.75,
  /** H3 heading multiplier (1.5x base font) */
  h3: 1.5,
  /** H4 heading multiplier (1.25x base font) */
  h4: 1.25,
  /** H5 heading multiplier (1.1x base font) */
  h5: 1.1,
  /** H6 heading multiplier (1x base font = same as body text) */
  h6: 1
};

// src/dom-registry.ts
var DOMRegistry = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  /**
   * Register a DOM element by key
   *
   * Stores an element reference for later retrieval and updates. Should be
   * called once per element during UI construction.
   *
   * @param key - Type-safe key for the element (from DOMElementKey union)
   * @param element - HTMLElement to store
   *
   * @example
   * ```typescript
   * const wpmValue = controlGroup.createSpan({ cls: CSS_CLASSES.wpmValue });
   * this.dom.register('wpmValue', wpmValue);
   * ```
   */
  register(key, element) {
    this.elements.set(key, element);
  }
  /**
   * Get a registered DOM element
   *
   * Retrieves the stored element reference. Returns undefined if the key
   * was never registered.
   *
   * @param key - Key of the element to retrieve
   * @returns The HTMLElement if registered, undefined otherwise
   *
   * @example
   * ```typescript
   * const wpmEl = this.dom.get('wpmValue');
   * if (wpmEl) {
   *   // Do something with the element
   * }
   * ```
   */
  get(key) {
    return this.elements.get(key);
  }
  /**
   * Update text content of a registered element (XSS-safe)
   *
   * Uses Obsidian's setText() method which safely escapes HTML.
   * Preferred over updateHTML() for displaying user-generated content.
   *
   * @param key - Key of the element to update
   * @param text - Text content to set (string or number)
   *
   * @example
   * ```typescript
   * this.dom.updateText('wpmValue', 350);
   * this.dom.updateText('statsText', 'Words: 42 / 1000');
   * ```
   */
  updateText(key, text) {
    const element = this.elements.get(key);
    if (element) {
      element.setText(String(text));
    }
  }
  /**
   * Update HTML content of a registered element
   *
   * **⚠️ WARNING**: Use with caution! Ensure content is properly escaped to
   * prevent XSS attacks. Prefer updateText() for plain text content.
   *
   * Only use this when you need to render HTML markup (e.g., syntax highlighting,
   * formatted text with spans, etc.) and you're certain the content is safe.
   *
   * @param key - Key of the element to update
   * @param html - HTML string to set (MUST be escaped if user-generated)
   *
   * @example
   * ```typescript
   * // Safe: Generated HTML with no user input
   * this.dom.updateHTML('wordEl', `<span class="highlight">Word</span>`);
   *
   * // UNSAFE: Never do this with user content
   * // this.dom.updateHTML('wordEl', userInput); // ❌ XSS risk!
   * ```
   */
  updateHTML(key, html) {
    const element = this.elements.get(key);
    if (element) {
      element.innerHTML = html;
    }
  }
  /**
   * Update a CSS style property of a registered element
   *
   * Modifies inline styles. Useful for dynamic styling like font size,
   * colors, or positioning.
   *
   * @param key - Key of the element to update
   * @param property - CSS property name (camelCase, e.g., 'fontSize')
   * @param value - CSS value as string (e.g., '48px', '#ff0000')
   *
   * @example
   * ```typescript
   * this.dom.updateStyle('wordEl', 'fontSize', '48px');
   * this.dom.updateStyle('wordEl', 'color', '#ff0000');
   * this.dom.updateStyle('progressBar', 'width', '50%');
   * ```
   */
  updateStyle(key, property, value) {
    const element = this.elements.get(key);
    if (element) {
      element.style[property] = value;
    }
  }
  /**
   * Toggle CSS class on a registered element
   *
   * Conditionally adds or removes a CSS class. Commonly used for show/hide
   * functionality with CSS_CLASSES.hidden.
   *
   * @param key - Key of the element to update
   * @param className - CSS class name to toggle
   * @param force - True to add class, false to remove it
   *
   * @example
   * ```typescript
   * // Show controls (remove 'hidden' class)
   * this.dom.toggleClass('controlsEl', CSS_CLASSES.hidden, false);
   *
   * // Hide controls (add 'hidden' class)
   * this.dom.toggleClass('controlsEl', CSS_CLASSES.hidden, true);
   * ```
   */
  toggleClass(key, className, force) {
    const element = this.elements.get(key);
    if (element) {
      element.toggleClass(className, force);
    }
  }
  /**
   * Add CSS class to a registered element
   *
   * Adds a CSS class if not already present. Use for state changes like
   * highlighting, active states, etc.
   *
   * @param key - Key of the element to update
   * @param className - CSS class name to add
   *
   * @example
   * ```typescript
   * this.dom.addClass('playBtn', 'active');
   * this.dom.addClass('wordEl', CSS_CLASSES.highlight);
   * ```
   */
  addClass(key, className) {
    const element = this.elements.get(key);
    if (element) {
      element.classList.add(className);
    }
  }
  /**
   * Remove CSS class from a registered element
   *
   * Removes a CSS class if present. Use for removing state classes.
   *
   * @param key - Key of the element to update
   * @param className - CSS class name to remove
   *
   * @example
   * ```typescript
   * this.dom.removeClass('playBtn', 'active');
   * this.dom.removeClass('wordEl', CSS_CLASSES.highlight);
   * ```
   */
  removeClass(key, className) {
    const element = this.elements.get(key);
    if (element) {
      element.classList.remove(className);
    }
  }
  /**
   * Empty the content of a registered element
   *
   * Removes all child nodes and text content. Useful for clearing containers
   * before re-rendering.
   *
   * @param key - Key of the element to empty
   *
   * @example
   * ```typescript
   * // Clear the word display before loading new text
   * this.dom.empty('wordEl');
   * ```
   */
  empty(key) {
    const element = this.elements.get(key);
    if (element) {
      element.empty();
    }
  }
  /**
   * Check if an element is registered
   *
   * Returns true if an element with the given key has been registered.
   *
   * @param key - Key to check
   * @returns True if the key is registered, false otherwise
   *
   * @example
   * ```typescript
   * if (this.dom.has('statsEl')) {
   *   this.dom.updateText('statsEl', 'New stats');
   * }
   * ```
   */
  has(key) {
    return this.elements.has(key);
  }
  /**
   * Clear all registered elements
   *
   * Removes all element references from the registry. Typically used during
   * cleanup or when rebuilding the entire UI.
   *
   * @example
   * ```typescript
   * // During onunload
   * this.dom.clear();
   * ```
   */
  clear() {
    this.elements.clear();
  }
  /**
   * Update multiple text elements at once (batch update)
   *
   * Efficiently updates text content of multiple elements in a single call.
   * More readable than multiple individual updateText() calls.
   *
   * @param updates - Object mapping element keys to new text values
   *
   * @example
   * ```typescript
   * // Update all WPM displays at once
   * this.dom.updateMultipleText({
   *   wpmDisplay: `${wpm} WPM`,
   *   wpmValue: String(wpm),
   *   wpmInlineValue: String(wpm)
   * });
   *
   * // Update stats panel
   * this.dom.updateMultipleText({
   *   statsText: `Words: ${wordsRead} / ${totalWords}`,
   *   progressBar: `${percent}%`
   * });
   * ```
   */
  updateMultipleText(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      if (value !== void 0) {
        this.updateText(key, value);
      }
    });
  }
  /**
   * Toggle visibility of multiple elements (batch visibility)
   *
   * Efficiently shows or hides multiple elements using CSS_CLASSES.hidden.
   * More readable than multiple individual toggleClass() calls.
   *
   * @param toggles - Object mapping element keys to visibility booleans (true = visible, false = hidden)
   *
   * @example
   * ```typescript
   * // Show play button, hide pause button
   * this.dom.toggleMultipleVisibility({
   *   playBtn: true,
   *   pauseBtn: false
   * });
   *
   * // Hide all panels
   * this.dom.toggleMultipleVisibility({
   *   controlsEl: false,
   *   settingsEl: false,
   *   statsEl: false
   * });
   * ```
   */
  toggleMultipleVisibility(toggles) {
    Object.entries(toggles).forEach(([key, visible]) => {
      if (typeof visible === "boolean") {
        this.toggleClass(key, CSS_CLASSES.hidden, !visible);
      }
    });
  }
};

// src/ui-builders.ts
function createButton(parent, config) {
  const className = config.className ? `${CSS_CLASSES.btn} ${config.className}` : CSS_CLASSES.btn;
  const btn = parent.createEl("button", {
    text: config.icon,
    cls: className,
    attr: { title: config.title }
  });
  btn.addEventListener("click", config.onClick);
  return btn;
}
function createNumberControl(parent, config, registry) {
  const container = parent.createDiv({ cls: CSS_CLASSES.controlGroup });
  container.createEl("span", {
    text: config.label,
    cls: CSS_CLASSES.controlLabel
  });
  createButton(container, {
    icon: config.decrementIcon || ICONS.decrement,
    title: config.decrementTitle || `Decrease (${config.increment || 1})`,
    onClick: config.onDecrement,
    className: CSS_CLASSES.smallBtn
  });
  const valueEl = container.createEl("span", {
    text: String(config.value),
    cls: config.registryKey || "value-display"
  });
  if (config.registryKey && registry) {
    registry.register(config.registryKey, valueEl);
  }
  createButton(container, {
    icon: config.incrementIcon || ICONS.increment,
    title: config.incrementTitle || `Increase (+${config.increment || 1})`,
    onClick: config.onIncrement,
    className: CSS_CLASSES.smallBtn
  });
  return { container, valueEl };
}
function createToggleControl(parent, config) {
  const container = parent.createDiv({ cls: CSS_CLASSES.settingGroup });
  const toggle = container.createEl("label", { cls: CSS_CLASSES.settingToggle });
  const checkbox = toggle.createEl("input", { type: "checkbox" });
  checkbox.checked = config.checked;
  checkbox.addEventListener("change", () => {
    config.onChange(checkbox.checked);
  });
  toggle.createEl("span", { text: ` ${config.label}` });
  return { container, checkbox };
}
function createPlayPauseButtons(parent, onPlay, onPause, registry) {
  const playBtn = createButton(parent, {
    icon: ICONS.play,
    title: "Play (Shift+Space)",
    onClick: onPlay,
    className: CSS_CLASSES.playBtn
  });
  const pauseBtn = createButton(parent, {
    icon: ICONS.pause,
    title: "Pause (Shift+Space)",
    onClick: onPause,
    className: `${CSS_CLASSES.pauseBtn} ${CSS_CLASSES.hidden}`
  });
  registry.register("playBtn", playBtn);
  registry.register("pauseBtn", pauseBtn);
}
function updatePlayPauseButtons(registry, isPlaying) {
  registry.toggleClass("playBtn", CSS_CLASSES.hidden, isPlaying);
  registry.toggleClass("pauseBtn", CSS_CLASSES.hidden, !isPlaying);
}
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}
function escapeHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function createWelcomeMessage() {
  return `
    <div style="font-size: 20px; color: var(--text-muted); text-align: center;">
      <div style="margin-bottom: 12px;">${ICONS.book} Select text to start reading</div>
      <div style="font-size: 14px; opacity: 0.7;">or use Cmd+P \u2192 "Read selected text"</div>
    </div>
  `;
}
function createReadyMessage(wordsToRead, totalWords, startIndex, durationText, sourceInfo = "") {
  const startInfo = startIndex !== void 0 && startIndex > 0 ? ` <span style="opacity: 0.6;">(starting at word ${startIndex + 1}/${totalWords})</span>` : "";
  return `
    <div style="font-size: 18px; color: var(--text-muted); text-align: center;">
      ${sourceInfo}
      Ready to read ${wordsToRead} words${startInfo}<br/>
      <span style="font-size: 14px; opacity: 0.7;">Estimated time: ~${durationText}</span><br/>
      <span style="font-size: 14px; opacity: 0.7;">Press Shift+Space to start</span>
    </div>
  `;
}

// src/auto-load-manager.ts
var import_obsidian = require("obsidian");
function isNavigationKey(evt) {
  return (
    // Arrow keys
    evt.key === "ArrowUp" || evt.key === "ArrowDown" || evt.key === "ArrowLeft" || evt.key === "ArrowRight" || // Home/End/PageUp/PageDown
    evt.key === "Home" || evt.key === "End" || evt.key === "PageUp" || evt.key === "PageDown" || // Enter
    evt.key === "Enter" || // Vim-style navigation
    evt.key === "j" && evt.ctrlKey || evt.key === "k" && evt.ctrlKey || evt.key === "d" && evt.ctrlKey || evt.key === "u" && evt.ctrlKey || // Cmd/Ctrl + arrows
    (evt.key === "ArrowUp" || evt.key === "ArrowDown") && (evt.metaKey || evt.ctrlKey)
  );
}
function isSelectionKey(evt) {
  return evt.shiftKey || evt.key === "a" && (evt.metaKey || evt.ctrlKey);
}
function extractEditorContent(app) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (!activeView) {
    return { activeView: null, currentFile: null };
  }
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile) {
    return { activeView, currentFile: null };
  }
  const fileName = currentFile.name;
  const editor = activeView.editor;
  let selection;
  let lineNumber;
  if (editor.somethingSelected()) {
    selection = editor.getSelection();
    const cursor2 = editor.getCursor("from");
    lineNumber = cursor2.line + 1;
  }
  const fullContent = editor.getValue();
  const cursor = editor.getCursor();
  const cursorPosition = editor.posToOffset(cursor);
  return {
    activeView,
    currentFile,
    fileName,
    selection,
    fullContent,
    cursorPosition,
    lineNumber
  };
}
var AutoLoadManager = class {
  /**
   * Creates a new AutoLoadManager instance
   *
   * @param app - Obsidian App instance for accessing workspace and editor
   * @param loadTextCallback - Callback function to load text into DashReader view
   * @param isViewShown - Function that returns true if DashReader view is currently visible
   *
   * @example
   * ```typescript
   * this.autoLoadManager = new AutoLoadManager(
   *   this.app,
   *   (text, source) => this.loadText(text, source),
   *   () => this.isViewShown
   * );
   * ```
   */
  constructor(app, loadTextCallback, isViewShown) {
    this.app = app;
    this.loadTextCallback = loadTextCallback;
    this.isViewShown = isViewShown;
    this.state = {
      lastSelection: "",
      lastFilePath: "",
      lastCursorPosition: -1,
      lastCheckTime: 0
    };
  }
  /**
   * Check for selection or cursor changes and load text if needed
   *
   * This is the main method called by keyboard and mouse event handlers.
   * It implements throttling (150ms) to avoid performance issues from
   * rapid event firing.
   *
   * **Logic Flow**:
   * 1. Throttle: Skip if less than 150ms since last check
   * 2. Extract editor content (selection, cursor position, etc.)
   * 3. Priority 1: If selection exists and changed → load selection
   * 4. Priority 2: If cursor moved → reload from new cursor position
   *
   * **Prevents Redundant Loads**:
   * - Tracks lastSelection to avoid reloading same text
   * - Tracks lastCursorPosition to avoid reload on unchanged position
   *
   * **Typical Usage**: Called on keyup and mouseup events
   *
   * @example
   * ```typescript
   * // In rsvp-view.ts setupAutoLoad()
   * this.registerDomEvent(document, 'keyup', (evt) => {
   *   if (isNavigationKey(evt) || isSelectionKey(evt)) {
   *     this.autoLoadManager.checkSelectionOrCursor();
   *   }
   * });
   *
   * this.registerDomEvent(document, 'mouseup', () => {
   *   this.autoLoadManager.checkSelectionOrCursor();
   * });
   * ```
   */
  checkSelectionOrCursor() {
    const now = Date.now();
    if (now - this.state.lastCheckTime < TIMING.throttleDelay) {
      return;
    }
    this.state.lastCheckTime = now;
    const content = extractEditorContent(this.app);
    if (!content.activeView || !content.currentFile) {
      return;
    }
    if (content.selection && content.selection.length > TEXT_LIMITS.minSelectionLength) {
      if (content.selection !== this.state.lastSelection) {
        this.state.lastSelection = content.selection;
        console.log(
          "DashReader: Auto-loading selection",
          content.selection.length,
          "characters from",
          content.fileName,
          "line",
          content.lineNumber
        );
        this.loadTextCallback(content.selection, {
          fileName: content.fileName,
          lineNumber: content.lineNumber
        });
      }
      return;
    }
    if (content.fullContent && content.fullContent.trim().length > TEXT_LIMITS.minContentLength) {
      if (content.cursorPosition !== this.state.lastCursorPosition) {
        const positionDiff = Math.abs(content.cursorPosition - this.state.lastCursorPosition);
        console.log(
          "DashReader: Cursor moved from",
          this.state.lastCursorPosition,
          "to",
          content.cursorPosition,
          "(diff:",
          positionDiff,
          ")"
        );
        console.log(
          "DashReader: Reloading from cursor position",
          content.cursorPosition,
          "in",
          content.fileName
        );
        this.loadTextCallback(content.fullContent, {
          fileName: content.fileName,
          cursorPosition: content.cursorPosition
        });
        this.state.lastSelection = "";
        this.state.lastCursorPosition = content.cursorPosition;
      }
    }
  }
  /**
   * Load content from the active editor with a configurable delay
   *
   * Used by file-open and leaf-change events to load content after a short
   * delay, giving Obsidian time to fully activate the editor.
   *
   * **Priority Logic**:
   * 1. If text is selected → load selection (rare on file open)
   * 2. Otherwise → load full document from cursor position
   *
   * **Delay Rationale**:
   * - file-open: 300ms default - editor needs time to initialize
   * - leaf-change: Can use shorter delay (200ms) - editor already active
   *
   * @param delay - Delay in milliseconds before loading (default: 300ms from TIMING.autoLoadDelay)
   *
   * @example
   * ```typescript
   * // File-open event (use default 300ms delay)
   * this.registerEvent(
   *   this.app.workspace.on('file-open', () => {
   *     this.autoLoadManager.loadFromEditor();
   *   })
   * );
   *
   * // Leaf-change event (use shorter 200ms delay)
   * this.registerEvent(
   *   this.app.workspace.on('active-leaf-change', () => {
   *     this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelayShort);
   *   })
   * );
   * ```
   */
  loadFromEditor(delay = TIMING.autoLoadDelay) {
    setTimeout(() => {
      if (!this.isViewShown())
        return;
      const content = extractEditorContent(this.app);
      if (!content.activeView || !content.currentFile)
        return;
      if (content.selection && content.selection.length > TEXT_LIMITS.minSelectionLength) {
        console.log(
          "DashReader: Auto-loading selection",
          content.selection.length,
          "characters from line",
          content.lineNumber
        );
        this.loadTextCallback(content.selection, {
          fileName: content.fileName,
          lineNumber: content.lineNumber
        });
        return;
      }
      if (content.fullContent && content.fullContent.trim().length > TEXT_LIMITS.minContentLength) {
        console.log("DashReader: Auto-loading entire page from cursor position", content.cursorPosition);
        this.loadTextCallback(content.fullContent, {
          fileName: content.fileName,
          cursorPosition: content.cursorPosition
        });
      }
    }, delay);
  }
  /**
   * Reset tracking state for a new file
   *
   * Called when the active file changes to clear previous selection and
   * cursor tracking. This prevents attempting to reload content from the
   * previous file's state.
   *
   * @param filePath - Path of the newly opened file
   *
   * @example
   * ```typescript
   * this.registerEvent(
   *   this.app.workspace.on('file-open', (file) => {
   *     if (file && this.autoLoadManager.hasFileChanged(file.path)) {
   *       this.autoLoadManager.resetForNewFile(file.path);
   *       this.autoLoadManager.loadFromEditor();
   *     }
   *   })
   * );
   * ```
   */
  resetForNewFile(filePath) {
    this.state.lastSelection = "";
    this.state.lastFilePath = filePath;
    this.state.lastCursorPosition = -1;
  }
  /**
   * Check if the file has changed
   *
   * Compares the given file path with the last tracked file path to determine
   * if the user has switched to a different file.
   *
   * @param filePath - File path to check
   * @returns True if the file path is different from the last tracked path
   *
   * @example
   * ```typescript
   * if (this.autoLoadManager.hasFileChanged(currentFile.path)) {
   *   console.log('User switched to a different file');
   *   this.autoLoadManager.resetForNewFile(currentFile.path);
   * }
   * ```
   */
  hasFileChanged(filePath) {
    return filePath !== this.state.lastFilePath;
  }
  /**
   * Get current state (for debugging)
   *
   * Returns a readonly copy of the internal state for debugging purposes.
   * Useful for understanding why auto-load is or isn't triggering.
   *
   * @returns Readonly copy of the current AutoLoadState
   *
   * @example
   * ```typescript
   * const state = this.autoLoadManager.getState();
   * console.log('AutoLoad state:', {
   *   lastSelection: state.lastSelection.substring(0, 50) + '...',
   *   lastFilePath: state.lastFilePath,
   *   lastCursorPosition: state.lastCursorPosition,
   *   lastCheckTime: new Date(state.lastCheckTime).toISOString()
   * });
   * ```
   */
  getState() {
    return { ...this.state };
  }
};

// src/rsvp-view.ts
var VIEW_TYPE_DASHREADER = "dashreader-view";
var DashReaderView = class extends import_obsidian2.ItemView {
  // ──────────────────────────────────────────────────────────────────────
  // Constructor
  // ──────────────────────────────────────────────────────────────────────
  /**
   * Creates a new DashReaderView instance
   *
   * @param leaf - Obsidian workspace leaf to attach to
   * @param settings - Plugin settings
   */
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
    this.state = new ViewState({
      currentWpm: settings.wpm,
      currentChunkSize: settings.chunkSize,
      currentFontSize: settings.fontSize
    });
    this.dom = new DOMRegistry();
    this.engine = new RSVPEngine(
      settings,
      this.onWordChange.bind(this),
      this.onComplete.bind(this)
    );
    this.autoLoadManager = new AutoLoadManager(
      this.app,
      this.loadText.bind(this),
      () => {
        var _a, _b;
        return (_b = (_a = this.mainContainerEl) == null ? void 0 : _a.isShown()) != null ? _b : false;
      }
    );
  }
  // ──────────────────────────────────────────────────────────────────────
  // Obsidian View Lifecycle
  // ──────────────────────────────────────────────────────────────────────
  /**
   * Returns the unique view type identifier
   * @returns View type string
   */
  getViewType() {
    return VIEW_TYPE_DASHREADER;
  }
  /**
   * Returns the display name shown in Obsidian UI
   * @returns Display name
   */
  getDisplayText() {
    return "DashReader";
  }
  /**
   * Returns the icon identifier for this view
   * @returns Icon name
   */
  getIcon() {
    return "zap";
  }
  /**
   * Called when the view is opened
   * Builds UI, sets up hotkeys, and registers auto-load
   */
  async onOpen() {
    this.mainContainerEl = this.contentEl.createDiv({ cls: CSS_CLASSES.container });
    this.buildUI();
    this.setupHotkeys();
    this.app.workspace.onLayoutReady(() => {
      this.setupAutoLoad();
    });
  }
  /**
   * Called when the view is closed
   * Stops reading and cleans up resources
   */
  async onClose() {
    this.engine.stop();
    this.dom.clear();
  }
  // ============================================================================
  // SECTION 3: UI CONSTRUCTION
  // ============================================================================
  /**
   * Orchestrates the construction of all UI components
   * Called once during view initialization
   *
   * Order matters: toggle bar, breadcrumb, stats, display, progress, controls, settings
   */
  buildUI() {
    this.buildToggleBar();
    this.buildBreadcrumb();
    this.buildStats();
    this.buildDisplayArea();
    this.buildProgressBar();
    this.buildControls();
    this.buildInlineSettings();
  }
  /**
   * Builds the toggle bar with settings and stats buttons
   * Located at the top of the view
   */
  buildToggleBar() {
    this.toggleBar = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.toggleBar });
    createButton(this.toggleBar, {
      icon: ICONS.settings,
      title: "Toggle controls (C)",
      onClick: () => this.togglePanel("controls"),
      className: CSS_CLASSES.toggleBtn
    });
    createButton(this.toggleBar, {
      icon: ICONS.stats,
      title: "Toggle stats (S)",
      onClick: () => this.togglePanel("stats"),
      className: CSS_CLASSES.toggleBtn
    });
  }
  /**
   * Builds the breadcrumb navigation bar
   * Shows the hierarchical position in the document (H1 > H2 > H3 etc.)
   * Updated automatically as reading progresses through headings
   */
  buildBreadcrumb() {
    this.breadcrumbEl = this.mainContainerEl.createDiv({
      cls: "dashreader-breadcrumb"
    });
    this.breadcrumbEl.style.display = "none";
  }
  /**
   * Builds the statistics display panel
   * Shows WPM, words read, time elapsed, etc.
   */
  buildStats() {
    this.statsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.stats} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("statsEl", this.statsEl);
    const wpmDisplay = this.statsEl.createDiv({ cls: CSS_CLASSES.wpmDisplay });
    wpmDisplay.setText(`${this.settings.wpm} WPM`);
    this.dom.register("wpmDisplay", wpmDisplay);
    const statsText = this.statsEl.createDiv({ cls: CSS_CLASSES.statsText });
    statsText.setText("Ready");
    this.dom.register("statsText", statsText);
  }
  /**
   * Builds the main display area for word presentation
   * Includes context before/after if enabled
   */
  buildDisplayArea() {
    const displayArea = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.display });
    if (this.settings.showContext) {
      this.contextBeforeEl = displayArea.createDiv({ cls: CSS_CLASSES.contextBefore });
      this.dom.register("contextBeforeEl", this.contextBeforeEl);
    }
    this.wordEl = displayArea.createDiv({ cls: CSS_CLASSES.word });
    this.wordEl.style.fontSize = `${this.settings.fontSize}px`;
    this.wordEl.style.fontFamily = this.settings.fontFamily;
    this.wordEl.style.color = this.settings.fontColor;
    this.wordEl.innerHTML = createWelcomeMessage();
    this.dom.register("wordEl", this.wordEl);
    if (this.settings.showContext) {
      this.contextAfterEl = displayArea.createDiv({ cls: CSS_CLASSES.contextAfter });
      this.dom.register("contextAfterEl", this.contextAfterEl);
    }
  }
  /**
   * Builds the progress bar at the bottom of display
   * Updates during reading to show progress
   */
  buildProgressBar() {
    this.progressEl = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.progressContainer });
    const progressBar = this.progressEl.createDiv({ cls: CSS_CLASSES.progressBar });
    progressBar.style.width = "0%";
    progressBar.style.background = this.settings.highlightColor;
    this.dom.register("progressBar", progressBar);
  }
  /**
   * Builds the playback controls panel
   * Includes play/pause, rewind, forward, stop, WPM, and chunk size controls
   */
  buildControls() {
    this.controlsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.controls} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("controlsEl", this.controlsEl);
    const playControls = this.controlsEl.createDiv({ cls: CSS_CLASSES.controlGroup });
    createButton(playControls, {
      icon: ICONS.rewind,
      title: "Rewind (\u2190)",
      onClick: () => this.engine.rewind()
    });
    createPlayPauseButtons(playControls, () => this.togglePlay(), () => this.engine.pause(), this.dom);
    createButton(playControls, {
      icon: ICONS.forward,
      title: "Forward (\u2192)",
      onClick: () => this.engine.forward()
    });
    createButton(playControls, {
      icon: ICONS.stop,
      title: "Stop (Esc)",
      onClick: () => this.engine.reset()
    });
    createNumberControl(
      this.controlsEl,
      {
        label: "WPM: ",
        value: this.settings.wpm,
        onIncrement: () => this.changeValue("wpm", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("wpm", -INCREMENTS.wpm),
        increment: INCREMENTS.wpm,
        registryKey: "wpmValue"
      },
      this.dom
    );
    createNumberControl(
      this.controlsEl,
      {
        label: "Words: ",
        value: this.settings.chunkSize,
        onIncrement: () => this.changeValue("chunkSize", INCREMENTS.chunkSize),
        onDecrement: () => this.changeValue("chunkSize", -INCREMENTS.chunkSize),
        registryKey: "chunkValue"
      },
      this.dom
    );
  }
  /**
   * Builds the inline settings panel
   * Allows quick adjustments to WPM, acceleration, font size, etc.
   */
  buildInlineSettings() {
    this.settingsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.settings} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("settingsEl", this.settingsEl);
    createNumberControl(
      this.settingsEl,
      {
        label: "Speed (WPM): ",
        value: this.settings.wpm,
        onIncrement: () => this.changeValue("wpm", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("wpm", -INCREMENTS.wpm),
        increment: INCREMENTS.wpm,
        registryKey: "wpmInlineValue",
        decrementTitle: "Slower (-25)",
        incrementTitle: "Faster (+25)"
      },
      this.dom
    );
    createToggleControl(this.settingsEl, {
      label: "Speed Acceleration",
      checked: this.settings.enableAcceleration,
      onChange: (checked) => {
        this.settings.enableAcceleration = checked;
        this.engine.updateSettings(this.settings);
        this.accelDurationGroup.style.display = checked ? "flex" : "none";
        this.accelTargetGroup.style.display = checked ? "flex" : "none";
      }
    });
    const accelDurationControl = createNumberControl(
      this.settingsEl,
      {
        label: "Accel Duration (s): ",
        value: this.settings.accelerationDuration,
        onIncrement: () => this.changeValue("accelDuration", INCREMENTS.accelDuration),
        onDecrement: () => this.changeValue("accelDuration", -INCREMENTS.accelDuration),
        registryKey: "accelDurationValue",
        decrementTitle: "Shorter (-5s)",
        incrementTitle: "Longer (+5s)"
      },
      this.dom
    );
    this.accelDurationGroup = accelDurationControl.container;
    this.accelDurationGroup.style.display = this.settings.enableAcceleration ? "flex" : "none";
    const accelTargetControl = createNumberControl(
      this.settingsEl,
      {
        label: "Target WPM: ",
        value: this.settings.accelerationTargetWpm,
        onIncrement: () => this.changeValue("accelTarget", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("accelTarget", -INCREMENTS.wpm),
        registryKey: "accelTargetValue",
        decrementTitle: "Lower (-25)",
        incrementTitle: "Higher (+25)"
      },
      this.dom
    );
    this.accelTargetGroup = accelTargetControl.container;
    this.accelTargetGroup.style.display = this.settings.enableAcceleration ? "flex" : "none";
    createNumberControl(
      this.settingsEl,
      {
        label: "Font Size: ",
        value: this.settings.fontSize,
        onIncrement: () => this.changeValue("fontSize", INCREMENTS.fontSize),
        onDecrement: () => this.changeValue("fontSize", -INCREMENTS.fontSize),
        registryKey: "fontValue",
        decrementTitle: "Smaller",
        incrementTitle: "Larger"
      },
      this.dom
    );
    createToggleControl(this.settingsEl, {
      label: "Show context",
      checked: this.settings.showContext,
      onChange: (checked) => {
        this.settings.showContext = checked;
        this.toggleContextDisplay();
      }
    });
    createToggleControl(this.settingsEl, {
      label: "Micropause",
      checked: this.settings.enableMicropause,
      onChange: (checked) => {
        this.settings.enableMicropause = checked;
        this.engine.updateSettings(this.settings);
      }
    });
  }
  // ============================================================================
  // SECTION 4: USER INTERACTIONS
  // ============================================================================
  /**
   * Unified value change handler
   * Replaces 5 separate change functions (changeWpm, changeWpmInline, etc.)
   *
   * @param type - Type of value to change
   * @param delta - Amount to change (positive or negative)
   */
  changeValue(type, delta) {
    switch (type) {
      case "wpm": {
        const newWpm = this.engine.getWpm() + delta;
        this.engine.setWpm(newWpm);
        this.settings.wpm = this.engine.getWpm();
        this.state.set("currentWpm", this.settings.wpm);
        this.dom.updateMultipleText({
          wpmDisplay: `${this.settings.wpm} WPM`,
          wpmValue: String(this.settings.wpm),
          wpmInlineValue: String(this.settings.wpm)
        });
        break;
      }
      case "chunkSize": {
        const newSize = this.engine.getChunkSize() + delta;
        this.engine.setChunkSize(newSize);
        this.settings.chunkSize = this.engine.getChunkSize();
        this.state.set("currentChunkSize", this.settings.chunkSize);
        this.dom.updateText("chunkValue", this.settings.chunkSize);
        break;
      }
      case "fontSize": {
        const newSize = Math.max(
          LIMITS.fontSize.min,
          Math.min(LIMITS.fontSize.max, this.settings.fontSize + delta)
        );
        this.settings.fontSize = newSize;
        this.state.set("currentFontSize", newSize);
        this.wordEl.style.fontSize = `${newSize}px`;
        this.dom.updateText("fontValue", newSize);
        break;
      }
      case "accelDuration": {
        const newDuration = Math.max(
          LIMITS.accelDuration.min,
          Math.min(LIMITS.accelDuration.max, this.settings.accelerationDuration + delta)
        );
        this.settings.accelerationDuration = newDuration;
        this.engine.updateSettings(this.settings);
        this.dom.updateText("accelDurationValue", newDuration);
        break;
      }
      case "accelTarget": {
        const newTarget = Math.max(
          LIMITS.wpm.min,
          Math.min(LIMITS.wpm.max, this.settings.accelerationTargetWpm + delta)
        );
        this.settings.accelerationTargetWpm = newTarget;
        this.engine.updateSettings(this.settings);
        this.dom.updateText("accelTargetValue", newTarget);
        break;
      }
    }
  }
  /**
   * Unified panel toggle handler
   * Replaces 3 separate toggle functions (toggleControls, toggleStats, etc.)
   *
   * @param panel - Panel to toggle ('controls' or 'stats')
   */
  togglePanel(panel) {
    if (panel === "controls") {
      this.state.toggle("showingControls");
      const showing = this.state.get("showingControls");
      this.controlsEl.toggleClass(CSS_CLASSES.hidden, !showing);
      this.settingsEl.toggleClass(CSS_CLASSES.hidden, !showing);
    } else if (panel === "stats") {
      this.state.toggle("showingStats");
      const showing = this.state.get("showingStats");
      this.statsEl.toggleClass(CSS_CLASSES.hidden, !showing);
    }
  }
  /**
   * Toggles the visibility of context before/after current word
   */
  toggleContextDisplay() {
    const display = this.settings.showContext ? "block" : "none";
    if (this.contextBeforeEl) {
      this.contextBeforeEl.style.display = display;
    }
    if (this.contextAfterEl) {
      this.contextAfterEl.style.display = display;
    }
  }
  // ============================================================================
  // SECTION 5: AUTO-LOAD SYSTEM
  // ============================================================================
  /**
   * Sets up automatic text loading from editor
   *
   * Registers event handlers for:
   * - file-open: Load text when opening a file
   * - active-leaf-change: Load text when switching files
   * - mouseup: Check for selection/cursor changes
   * - keyup: Check for navigation/selection keys
   *
   * Actual tracking logic is encapsulated in AutoLoadManager
   */
  setupAutoLoad() {
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (!file)
          return;
        this.autoLoadManager.resetForNewFile(file.path);
        console.log("DashReader: File opened:", file.path);
        this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelay);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        if (!this.mainContainerEl || !this.mainContainerEl.isShown())
          return;
        console.log("DashReader: Active leaf changed");
        const currentFile = this.app.workspace.getActiveFile();
        if (currentFile && this.autoLoadManager.hasFileChanged(currentFile.path)) {
          this.autoLoadManager.resetForNewFile(currentFile.path);
          this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelayShort);
        }
      })
    );
    this.registerDomEvent(document, "mouseup", () => {
      console.log("DashReader: Mouse click detected");
      setTimeout(() => {
        if (this.mainContainerEl.isShown()) {
          this.autoLoadManager.checkSelectionOrCursor();
        }
      }, TIMING.autoLoadDelayVeryShort);
    });
    this.registerDomEvent(document, "keyup", (evt) => {
      if (isNavigationKey(evt) || isSelectionKey(evt)) {
        console.log("DashReader: Navigation key detected:", evt.key, "with modifiers:", {
          shift: evt.shiftKey,
          ctrl: evt.ctrlKey,
          meta: evt.metaKey
        });
        setTimeout(() => {
          if (this.mainContainerEl.isShown()) {
            this.autoLoadManager.checkSelectionOrCursor();
          }
        }, TIMING.autoLoadDelayVeryShort);
      }
    });
    console.log("DashReader: Auto-load setup complete");
  }
  // ============================================================================
  // SECTION 6: HOTKEYS & KEYBOARD
  // ============================================================================
  /**
   * Sets up keyboard shortcuts for playback control
   */
  setupHotkeys() {
    document.addEventListener("keydown", this.handleKeyPress.bind(this));
  }
  /**
   * Handles keyboard shortcuts
   *
   * Shortcuts:
   * - C: Toggle controls (when not playing)
   * - S: Toggle stats (when not playing)
   * - Shift+Space: Play/Pause
   * - Arrow keys: Rewind/Forward, WPM adjustment
   * - Escape: Stop reading
   *
   * @param e - Keyboard event
   */
  handleKeyPress(e) {
    if (!this.mainContainerEl.isShown())
      return;
    if (e.key === "c" && !this.engine.getIsPlaying()) {
      e.preventDefault();
      this.togglePanel("controls");
      return;
    }
    if (e.key === "s" && !this.engine.getIsPlaying()) {
      e.preventDefault();
      this.togglePanel("stats");
      return;
    }
    const keyCode = e.code || e.key;
    if (keyCode === "Space" && e.shiftKey) {
      e.preventDefault();
      console.log("DashReader: Shift+Space pressed, toggling play");
      this.togglePlay();
      return;
    }
    switch (keyCode) {
      case this.settings.hotkeyRewind:
        e.preventDefault();
        this.engine.rewind();
        break;
      case this.settings.hotkeyForward:
        e.preventDefault();
        this.engine.forward();
        break;
      case this.settings.hotkeyIncrementWpm:
        e.preventDefault();
        this.changeValue("wpm", INCREMENTS.wpm);
        break;
      case this.settings.hotkeyDecrementWpm:
        e.preventDefault();
        this.changeValue("wpm", -INCREMENTS.wpm);
        break;
      case this.settings.hotkeyQuit:
        e.preventDefault();
        this.engine.stop();
        break;
    }
  }
  /**
   * Toggles play/pause state
   * Updates UI buttons accordingly
   */
  togglePlay() {
    if (this.engine.getIsPlaying()) {
      this.engine.pause();
      updatePlayPauseButtons(this.dom, false);
    } else {
      if (this.state.get("startTime") === 0) {
        this.state.set("startTime", Date.now());
      }
      this.engine.play();
      updatePlayPauseButtons(this.dom, true);
    }
  }
  // ============================================================================
  // SECTION 7: READING ENGINE CALLBACKS
  // ============================================================================
  /**
   * Called by engine when a new word is displayed
   * Updates the UI with the current word, context, progress, and stats
   *
   * @param chunk - Word chunk with text, index, delay info
   */
  onWordChange(chunk) {
    const headingMatch = chunk.text.match(/^\[H(\d)\]/);
    const calloutMatch = chunk.text.match(/^\[CALLOUT:([\w-]+)\]/);
    let displayText = chunk.text;
    let headingLevel = 0;
    let showSeparator = false;
    let calloutType;
    if (headingMatch) {
      headingLevel = parseInt(headingMatch[1]);
      displayText = chunk.text.replace(/^\[H\d\]/, "");
      showSeparator = true;
      console.log("DashReader: Heading detected - Level", headingLevel, "Text:", displayText);
    } else if (calloutMatch) {
      calloutType = calloutMatch[1];
      displayText = chunk.text.replace(/^\[CALLOUT:[\w-]+\]/, "");
      showSeparator = true;
      console.log("DashReader: Callout detected - Type", calloutType, "Text:", displayText);
    }
    this.displayWordWithHeading(displayText, headingLevel, showSeparator, calloutType);
    if (chunk.headingContext) {
      this.updateBreadcrumb(chunk.headingContext);
    }
    if (this.settings.showContext && this.contextBeforeEl && this.contextAfterEl) {
      const context = this.engine.getContext(this.settings.contextWords);
      this.contextBeforeEl.setText(context.before.join(" "));
      this.contextAfterEl.setText(context.after.join(" "));
    }
    const progress = this.engine.getProgress();
    this.dom.updateStyle("progressBar", "width", `${progress}%`);
    this.state.increment("wordsRead");
    this.updateStats();
  }
  /**
   * Displays a word with heading or callout-based styling
   *
   * @param word - Word to display
   * @param headingLevel - Heading level (1-6) or 0 for normal text/callouts
   * @param showSeparator - Whether to show separator line before heading/callout
   * @param calloutType - Callout type (note, abstract, info, etc.) if this is a callout
   */
  displayWordWithHeading(word, headingLevel, showSeparator = false, calloutType) {
    const calloutIcons = {
      note: "\u{1F4DD}",
      abstract: "\u{1F4C4}",
      info: "\u2139\uFE0F",
      tip: "\u{1F4A1}",
      success: "\u2705",
      question: "\u2753",
      warning: "\u26A0\uFE0F",
      failure: "\u274C",
      danger: "\u26A1",
      bug: "\u{1F41B}",
      example: "\u{1F4CB}",
      quote: "\u{1F4AC}"
    };
    let fontSizeMultiplier = 1;
    let fontWeight = "normal";
    let prefix = "";
    if (calloutType) {
      fontSizeMultiplier = 1.2;
      fontWeight = "bold";
      const icon = calloutIcons[calloutType.toLowerCase()] || "\u{1F4CC}";
      prefix = `<span style="margin-right: 8px; opacity: 0.8;">${icon}</span>`;
    } else if (headingLevel > 0) {
      const multipliers = [
        0,
        HEADING_MULTIPLIERS.h1,
        HEADING_MULTIPLIERS.h2,
        HEADING_MULTIPLIERS.h3,
        HEADING_MULTIPLIERS.h4,
        HEADING_MULTIPLIERS.h5,
        HEADING_MULTIPLIERS.h6
      ];
      fontSizeMultiplier = multipliers[headingLevel] || 1;
      fontWeight = "bold";
    }
    const adjustedFontSize = this.settings.fontSize * fontSizeMultiplier;
    const processedWord = this.processWord(word);
    const separator = showSeparator ? `<div style="width: 60%; height: 2px; background: var(--text-muted); opacity: 0.4; margin: 0 auto 20px auto;"></div>` : "";
    this.wordEl.innerHTML = `
      ${separator}
      <div style="font-size: ${adjustedFontSize}px; transition: font-size 0.3s ease; font-weight: ${fontWeight};">
        ${prefix}${processedWord}
      </div>
    `;
  }
  /**
   * Processes a word for display with center character highlighting
   * Escapes HTML to prevent XSS attacks
   *
   * @param word - Word to process
   * @returns HTML string with highlighted center character
   */
  processWord(word) {
    const cleanWord = word.trim();
    const center = Math.max(Math.floor(cleanWord.length / 2) - 1, 0);
    let result = "";
    for (let i = 0; i < cleanWord.length; i++) {
      const escapedChar = escapeHtml(cleanWord[i]);
      if (i === center) {
        result += `<span class="${CSS_CLASSES.highlight}" style="color: ${this.settings.highlightColor}">${escapedChar}</span>`;
      } else {
        result += escapedChar;
      }
    }
    return result;
  }
  /**
   * Updates the breadcrumb navigation bar with current heading context
   * Shows hierarchical path (H1 > H2 > H3) and makes it clickable for navigation
   *
   * @param context - Current heading context from engine
   */
  updateBreadcrumb(context) {
    if (!context || context.breadcrumb.length === 0) {
      this.breadcrumbEl.style.display = "none";
      return;
    }
    this.breadcrumbEl.style.display = "block";
    this.breadcrumbEl.empty();
    const calloutIcons = {
      note: "\u{1F4DD}",
      abstract: "\u{1F4C4}",
      info: "\u2139\uFE0F",
      tip: "\u{1F4A1}",
      success: "\u2705",
      question: "\u2753",
      warning: "\u26A0\uFE0F",
      failure: "\u274C",
      danger: "\u26A1",
      bug: "\u{1F41B}",
      example: "\u{1F4CB}",
      quote: "\u{1F4AC}"
    };
    context.breadcrumb.forEach((heading, index) => {
      if (index > 0) {
        const separator = this.breadcrumbEl.createSpan({
          cls: "dashreader-breadcrumb-separator",
          text: " \u203A "
        });
        separator.style.opacity = "0.5";
        separator.style.margin = "0 8px";
      }
      let displayText = heading.text;
      if (heading.calloutType) {
        const icon = calloutIcons[heading.calloutType.toLowerCase()] || "\u{1F4CC}";
        displayText = `${icon} ${heading.text}`;
      }
      const item = this.breadcrumbEl.createSpan({
        cls: "dashreader-breadcrumb-item",
        text: displayText
      });
      const isLast = index === context.breadcrumb.length - 1;
      item.style.cursor = "pointer";
      item.style.opacity = isLast ? "1" : "0.7";
      item.style.fontWeight = isLast ? "bold" : "normal";
      if (heading.calloutType) {
        item.style.fontSize = "14px";
      } else {
        item.style.fontSize = `${12 + 2 * (6 - heading.level)}px`;
      }
      item.addEventListener("mouseenter", () => {
        item.style.opacity = "1";
        item.style.textDecoration = "underline";
      });
      item.addEventListener("mouseleave", () => {
        item.style.opacity = isLast ? "1" : "0.7";
        item.style.textDecoration = "none";
      });
      item.addEventListener("click", () => {
        this.navigateToHeading(heading.wordIndex);
      });
    });
  }
  /**
   * Navigates to a specific heading by word index
   * Pauses playback, jumps to the heading position, and resumes if it was playing
   *
   * @param wordIndex - Word index to navigate to
   */
  navigateToHeading(wordIndex) {
    const wasPlaying = this.engine.getIsPlaying();
    if (wasPlaying) {
      this.engine.pause();
    }
    const currentIndex = this.engine.getCurrentIndex();
    const delta = wordIndex - currentIndex;
    if (delta < 0) {
      this.engine.rewind(Math.abs(delta));
    } else if (delta > 0) {
      this.engine.forward(delta);
    }
    if (wasPlaying) {
      this.engine.play();
    }
  }
  /**
   * Called by engine when reading is complete
   * Updates UI to show completion message
   */
  onComplete() {
    updatePlayPauseButtons(this.dom, false);
    this.dom.updateText("statsText", `Completed! ${ICONS.celebration}`);
  }
  /**
   * Updates the stats display with current reading statistics
   * Shows: words read, elapsed time, current WPM, remaining time
   */
  updateStats() {
    const elapsed = this.engine.getElapsedTime();
    const currentWpm = this.engine.getCurrentWpmPublic();
    const remaining = this.engine.getRemainingTime();
    const wordsRead = this.state.get("wordsRead");
    this.dom.updateText(
      "statsText",
      `${wordsRead}/${this.engine.getTotalWords()} words | ${formatTime(elapsed)} | ${currentWpm} WPM | ${formatTime(remaining)} left`
    );
  }
  // ============================================================================
  // SECTION 8: TEXT LOADING
  // ============================================================================
  /**
   * Loads text for reading
   *
   * Process:
   * 1. Stop current reading if playing
   * 2. Parse markdown to plain text
   * 3. Calculate word index from cursor position (if provided)
   * 4. Validate text length
   * 5. Load into engine
   * 6. Update UI with ready message
   * 7. Auto-start if enabled
   *
   * @param text - Text to load (raw markdown)
   * @param source - Optional source information (filename, line, cursor position)
   */
  loadText(text, source) {
    console.log("DashReader: loadText called with source:", source);
    if (this.engine.getIsPlaying()) {
      this.engine.stop();
      updatePlayPauseButtons(this.dom, false);
      console.log("DashReader: Stopped current reading");
    }
    console.log("DashReader: Parsing markdown, original length:", text.length);
    const plainText = MarkdownParser.parseToPlainText(text);
    console.log("DashReader: After parsing, length:", plainText.length);
    console.log("DashReader: First 100 chars:", plainText.substring(0, 100));
    let wordIndexFromCursor;
    if ((source == null ? void 0 : source.cursorPosition) !== void 0) {
      console.log("DashReader: Cursor position detected:", source.cursorPosition);
      const textUpToCursor = text.substring(0, source.cursorPosition);
      const parsedUpToCursor = MarkdownParser.parseToPlainText(textUpToCursor);
      const wordsBeforeCursor = parsedUpToCursor.trim().split(/\s+/).filter((w) => w.length > 0);
      wordIndexFromCursor = wordsBeforeCursor.length;
      console.log("DashReader: Original text up to cursor:", textUpToCursor.length, "chars");
      console.log("DashReader: Parsed text up to cursor:", parsedUpToCursor.length, "chars");
      console.log("DashReader: Words before cursor (after parsing):", wordsBeforeCursor.slice(0, 10), "...");
      console.log("DashReader: Cursor at character", source.cursorPosition, "\u2192 word index", wordIndexFromCursor, "(in parsed text)");
    } else {
      console.log("DashReader: No cursor position provided");
    }
    if (!plainText || plainText.trim().length < TEXT_LIMITS.minParsedLength) {
      console.log("DashReader: Text too short after parsing");
      return;
    }
    this.engine.setText(plainText, void 0, wordIndexFromCursor);
    this.state.update({ wordsRead: 0, startTime: 0 });
    const welcomeMsg = this.wordEl.querySelector(`.${CSS_CLASSES.welcome}`);
    if (welcomeMsg) {
      welcomeMsg.remove();
    }
    this.wordEl.empty();
    let sourceInfo = "";
    if (source == null ? void 0 : source.fileName) {
      const escapedFileName = escapeHtml(source.fileName);
      const lineInfo = source.lineNumber ? ` (line ${source.lineNumber})` : "";
      sourceInfo = `<div style="font-size: 14px; opacity: 0.6; margin-bottom: 8px;">
        ${ICONS.file} ${escapedFileName}${lineInfo}
      </div>`;
    }
    const totalWords = this.engine.getTotalWords();
    const remainingWords = this.engine.getRemainingWords();
    const estimatedDuration = this.engine.getEstimatedDuration();
    const durationText = formatTime(estimatedDuration);
    const fileInfo = (source == null ? void 0 : source.fileName) ? ` from ${source.fileName}` : "";
    const wordInfo = wordIndexFromCursor && wordIndexFromCursor > 0 ? `${remainingWords}/${totalWords} words` : `${totalWords} words`;
    this.dom.updateText("statsText", `${wordInfo} loaded${fileInfo} - ~${durationText} - Shift+Space to start`);
    this.wordEl.innerHTML = createReadyMessage(remainingWords, totalWords, wordIndexFromCursor, durationText, sourceInfo);
    console.log("DashReader: Words to read:", remainingWords, "out of", totalWords);
    if (this.settings.autoStart) {
      setTimeout(() => {
        this.engine.play();
        updatePlayPauseButtons(this.dom, true);
        this.state.set("startTime", Date.now());
      }, this.settings.autoStartDelay * 1e3);
    }
  }
  // ============================================================================
  // SECTION 9: SETTINGS & LIFECYCLE
  // ============================================================================
  /**
   * Updates settings from plugin settings tab
   * Called when user changes settings in main settings panel
   *
   * @param settings - New settings
   */
  updateSettings(settings) {
    this.settings = settings;
    this.engine.updateSettings(settings);
    if (this.wordEl) {
      this.wordEl.style.fontSize = `${settings.fontSize}px`;
      this.wordEl.style.fontFamily = settings.fontFamily;
      this.wordEl.style.color = settings.fontColor;
    }
    this.dom.updateText("wpmDisplay", `${settings.wpm} WPM`);
  }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DashReaderSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "DashReader Settings" });
    containerEl.createEl("h3", { text: "Reading Settings" });
    new import_obsidian3.Setting(containerEl).setName("Words per minute (WPM)").setDesc("Reading speed (50-1000)").addSlider((slider) => slider.setLimits(50, 1e3, 25).setValue(this.plugin.settings.wpm).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.wpm = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Words at a time").setDesc("Number of words displayed simultaneously (1-5)").addSlider((slider) => slider.setLimits(1, 5, 1).setValue(this.plugin.settings.chunkSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chunkSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Font size").setDesc("Font size in pixels (20-120px)").addSlider((slider) => slider.setLimits(20, 120, 4).setValue(this.plugin.settings.fontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.fontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Font family").setDesc("Font family for text display").addDropdown((dropdown) => dropdown.addOption("inherit", "Default").addOption("monospace", "Monospace").addOption("serif", "Serif").addOption("sans-serif", "Sans-serif").setValue(this.plugin.settings.fontFamily).onChange(async (value) => {
      this.plugin.settings.fontFamily = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Speed Acceleration" });
    new import_obsidian3.Setting(containerEl).setName("Enable acceleration").setDesc("Gradually increase reading speed over time").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAcceleration).onChange(async (value) => {
      this.plugin.settings.enableAcceleration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Acceleration duration").setDesc("Duration to reach target speed (seconds)").addSlider((slider) => slider.setLimits(10, 120, 5).setValue(this.plugin.settings.accelerationDuration).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.accelerationDuration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Target WPM").setDesc("Target reading speed to reach (50-1000)").addSlider((slider) => slider.setLimits(50, 1e3, 25).setValue(this.plugin.settings.accelerationTargetWpm).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.accelerationTargetWpm = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian3.Setting(containerEl).setName("Highlight color").setDesc("Color for the center character highlight").addText((text) => text.setPlaceholder("#4a9eff").setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
      this.plugin.settings.highlightColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Font color").setDesc("Text color").addText((text) => text.setPlaceholder("#ffffff").setValue(this.plugin.settings.fontColor).onChange(async (value) => {
      this.plugin.settings.fontColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Background color").setDesc("Background color").addText((text) => text.setPlaceholder("#1e1e1e").setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
      this.plugin.settings.backgroundColor = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Context Display" });
    new import_obsidian3.Setting(containerEl).setName("Show context").setDesc("Display words before and after current word").addToggle((toggle) => toggle.setValue(this.plugin.settings.showContext).onChange(async (value) => {
      this.plugin.settings.showContext = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Context words").setDesc("Number of context words to display (1-10)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWords).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.contextWords = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Micropause" });
    new import_obsidian3.Setting(containerEl).setName("Enable micropause").setDesc("Automatic pauses based on punctuation and word length").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMicropause).onChange(async (value) => {
      this.plugin.settings.enableMicropause = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Punctuation pause").setDesc("Pause multiplier for punctuation (1.0-3.0)").addSlider((slider) => slider.setLimits(1, 3, 0.1).setValue(this.plugin.settings.micropausePunctuation).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropausePunctuation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Long words pause").setDesc("Pause multiplier for long words (1.0-2.0)").addSlider((slider) => slider.setLimits(1, 2, 0.1).setValue(this.plugin.settings.micropauseLongWords).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropauseLongWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Paragraph pause").setDesc("Pause multiplier for paragraph breaks (1.0-5.0)").addSlider((slider) => slider.setLimits(1, 5, 0.5).setValue(this.plugin.settings.micropauseParagraph).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropauseParagraph = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto-start" });
    new import_obsidian3.Setting(containerEl).setName("Auto-start reading").setDesc("Automatically start reading after text loads").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStart).onChange(async (value) => {
      this.plugin.settings.autoStart = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Auto-start delay").setDesc("Delay before auto-start (seconds)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.autoStartDelay).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autoStartDelay = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Display Options" });
    new import_obsidian3.Setting(containerEl).setName("Show progress bar").setDesc("Display reading progress bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showProgress).onChange(async (value) => {
      this.plugin.settings.showProgress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Show statistics").setDesc("Display reading statistics").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStats).onChange(async (value) => {
      this.plugin.settings.showStats = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Keyboard Shortcuts" });
    containerEl.createEl("p", {
      text: "Note: Hotkey customization is available in Obsidian's Hotkeys settings.",
      cls: "setting-item-description"
    });
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  wpm: 400,
  // Increased from 300 (inspired by Stutter: 400-800 range)
  chunkSize: 1,
  fontSize: 48,
  highlightColor: "#4a9eff",
  backgroundColor: "#1e1e1e",
  fontColor: "#ffffff",
  fontFamily: "inherit",
  showContext: true,
  contextWords: 3,
  enableMicropause: true,
  micropausePunctuation: 2.5,
  // Increased from 1.5 (Stutter: 2.5 for sentences)
  micropauseLongWords: 1.4,
  // Increased from 1.3 (Stutter: 1.4)
  micropauseParagraph: 2.5,
  // Increased from 2.0 for better section separation
  autoStart: false,
  autoStartDelay: 3,
  showProgress: true,
  showStats: true,
  hotkeyPlay: "Space",
  hotkeyRewind: "ArrowLeft",
  hotkeyForward: "ArrowRight",
  hotkeyIncrementWpm: "ArrowUp",
  hotkeyDecrementWpm: "ArrowDown",
  hotkeyQuit: "Escape",
  enableAcceleration: false,
  accelerationDuration: 30,
  accelerationTargetWpm: 600
  // Increased from 450 (Stutter suggests 600-800)
};

// main.ts
var DashReaderPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
  }
  async onload() {
    console.log("Loading DashReader plugin");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_DASHREADER,
      (leaf) => {
        this.view = new DashReaderView(leaf, this.settings);
        return this.view;
      }
    );
    this.addRibbonIcon("zap", "Open DashReader", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-dashreader",
      name: "Open DashReader",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "read-selection",
      name: "Read selected text",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.activateView().then(() => {
            if (this.view) {
              this.view.loadText(selection);
            }
          });
        } else {
          new import_obsidian4.Notice("Please select some text first");
        }
      }
    });
    this.addCommand({
      id: "read-note",
      name: "Read entire note",
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (activeView) {
          const content = activeView.editor.getValue();
          this.activateView().then(() => {
            if (this.view) {
              this.view.loadText(content);
            }
          });
        } else {
          new import_obsidian4.Notice("No active note found");
        }
      }
    });
    this.addCommand({
      id: "toggle-play-pause",
      name: "Toggle Play/Pause",
      callback: () => {
        new import_obsidian4.Notice("Use Shift+Space key when DashReader is active");
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Read with DashReader").setIcon("zap").onClick(() => {
              this.activateView().then(() => {
                if (this.view) {
                  this.view.loadText(selection);
                }
              });
            });
          });
        }
      })
    );
    this.addSettingTab(new DashReaderSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.view) {
          this.view.updateSettings(this.settings);
        }
      })
    );
    console.log("DashReader plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading DashReader plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.view) {
      this.view.updateSettings(this.settings);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_DASHREADER);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_DASHREADER,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      this.view = leaf.view;
    }
  }
};
