/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DashReaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/rsvp-view.ts
var import_obsidian2 = require("obsidian");

// src/rsvp-engine.ts
var RSVPEngine = class {
  constructor(settings, onWordChange, onComplete) {
    this.words = [];
    this.currentIndex = 0;
    this.isPlaying = false;
    this.timer = null;
    this.startTime = 0;
    this.startWpm = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.settings = settings;
    this.onWordChange = onWordChange;
    this.onComplete = onComplete;
  }
  setText(text, startPosition, startWordIndex) {
    console.log("DashReader Engine: setText called with startPosition:", startPosition, "startWordIndex:", startWordIndex);
    const cleaned = text.replace(/\s+/g, " ").replace(/\n+/g, "\n").trim();
    this.words = cleaned.split(/\s+/);
    console.log("DashReader Engine: Total words after split:", this.words.length);
    if (startWordIndex !== void 0) {
      this.currentIndex = Math.max(0, Math.min(startWordIndex, this.words.length - 1));
      console.log("DashReader Engine: Starting at word index", this.currentIndex, "/", this.words.length, "(from startWordIndex)");
    } else if (startPosition !== void 0 && startPosition > 0) {
      const textUpToCursor = text.substring(0, startPosition);
      const wordsBeforeCursor = textUpToCursor.trim().split(/\s+/).length;
      this.currentIndex = Math.min(wordsBeforeCursor, this.words.length - 1);
      console.log("DashReader Engine: Starting at word index", this.currentIndex, "/", this.words.length, "(from startPosition)");
    } else {
      this.currentIndex = 0;
      console.log("DashReader Engine: Starting at beginning (no start position)");
    }
  }
  play() {
    if (this.isPlaying)
      return;
    if (this.currentIndex >= this.words.length) {
      this.currentIndex = 0;
    }
    this.isPlaying = true;
    if (this.startTime === 0) {
      this.startTime = Date.now();
      this.startWpm = this.settings.wpm;
    } else if (this.lastPauseTime > 0) {
      this.pausedTime += Date.now() - this.lastPauseTime;
      this.lastPauseTime = 0;
    }
    this.displayNextWord();
  }
  pause() {
    this.isPlaying = false;
    if (this.timer !== null) {
      window.clearTimeout(this.timer);
      this.timer = null;
    }
    this.lastPauseTime = Date.now();
  }
  stop() {
    this.pause();
    this.currentIndex = 0;
    this.startTime = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.startWpm = 0;
  }
  reset() {
    this.stop();
  }
  rewind(steps = 10) {
    this.currentIndex = Math.max(0, this.currentIndex - steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  forward(steps = 10) {
    this.currentIndex = Math.min(this.words.length - 1, this.currentIndex + steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  displayCurrentWord() {
    if (this.currentIndex >= this.words.length) {
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
  }
  displayNextWord() {
    if (!this.isPlaying || this.currentIndex >= this.words.length) {
      if (this.currentIndex >= this.words.length) {
        this.isPlaying = false;
        this.onComplete();
      }
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
    const delay = this.calculateDelay(chunk.text);
    this.currentIndex += this.settings.chunkSize;
    this.timer = window.setTimeout(() => {
      this.displayNextWord();
    }, delay);
  }
  getChunk(startIndex) {
    const endIndex = Math.min(
      startIndex + this.settings.chunkSize,
      this.words.length
    );
    const chunkWords = this.words.slice(startIndex, endIndex);
    const text = chunkWords.join(" ");
    return {
      text,
      index: startIndex,
      delay: this.calculateDelay(text),
      isEnd: endIndex >= this.words.length
    };
  }
  getCurrentWpm() {
    if (!this.settings.enableAcceleration || this.startTime === 0) {
      return this.settings.wpm;
    }
    const elapsed = (Date.now() - this.startTime - this.pausedTime) / 1e3;
    if (elapsed >= this.settings.accelerationDuration) {
      return this.settings.accelerationTargetWpm;
    }
    const progress = elapsed / this.settings.accelerationDuration;
    const wpmDiff = this.settings.accelerationTargetWpm - this.startWpm;
    const currentWpm = this.startWpm + wpmDiff * progress;
    return Math.round(currentWpm);
  }
  calculateDelay(text) {
    const currentWpm = this.getCurrentWpm();
    const baseDelay = 60 / currentWpm * 1e3;
    if (!this.settings.enableMicropause) {
      return baseDelay;
    }
    let multiplier = 1;
    const trimmedText = text.trim();
    const headingMatch = trimmedText.match(/^\[H(\d)\]/);
    if (headingMatch) {
      const level = parseInt(headingMatch[1]);
      const headingMultipliers = [0, 3, 2.5, 2, 1.8, 1.5, 1.3];
      multiplier *= headingMultipliers[level] || 2;
    }
    if (/^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmedText)) {
      multiplier *= 2;
    }
    if (/^[-*+•]/.test(trimmedText)) {
      multiplier *= 1.8;
    }
    if (/[.!?;:]$/.test(text)) {
      multiplier *= this.settings.micropausePunctuation;
    } else if (/[,]$/.test(text)) {
      multiplier *= Math.max(1, this.settings.micropausePunctuation - 0.3);
    }
    if (text.length > 8) {
      multiplier *= this.settings.micropauseLongWords;
    }
    if (text.includes("\n")) {
      multiplier *= this.settings.micropauseParagraph;
    }
    return baseDelay * multiplier;
  }
  getProgress() {
    return this.words.length > 0 ? this.currentIndex / this.words.length * 100 : 0;
  }
  getCurrentIndex() {
    return this.currentIndex;
  }
  getTotalWords() {
    return this.words.length;
  }
  getIsPlaying() {
    return this.isPlaying;
  }
  setWpm(wpm) {
    this.settings.wpm = Math.max(50, Math.min(1e3, wpm));
  }
  getWpm() {
    return this.settings.wpm;
  }
  setChunkSize(size) {
    this.settings.chunkSize = Math.max(1, Math.min(5, size));
  }
  getChunkSize() {
    return this.settings.chunkSize;
  }
  getContext(contextWords = 3) {
    const beforeStart = Math.max(0, this.currentIndex - contextWords);
    const afterEnd = Math.min(this.words.length, this.currentIndex + this.settings.chunkSize + contextWords);
    return {
      before: this.words.slice(beforeStart, this.currentIndex),
      after: this.words.slice(this.currentIndex + this.settings.chunkSize, afterEnd)
    };
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getEstimatedDuration() {
    if (this.words.length === 0)
      return 0;
    const remainingWords = Math.max(0, this.words.length - this.currentIndex);
    if (remainingWords === 0)
      return 0;
    const averageWpm = this.settings.enableAcceleration ? (this.settings.wpm + this.settings.accelerationTargetWpm) / 2 : this.settings.wpm;
    return this.calculateAccurateRemainingTime(averageWpm);
  }
  calculateAccurateRemainingTime(wpm) {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    let totalTimeMs = 0;
    const baseDelay = 60 / wpm * 1e3;
    for (let i = this.currentIndex; i < this.words.length; i++) {
      const word = this.words[i];
      if (!this.settings.enableMicropause) {
        totalTimeMs += baseDelay;
        continue;
      }
      let multiplier = 1;
      const trimmedText = word.trim();
      const headingMatch = trimmedText.match(/^\[H(\d)\]/);
      if (headingMatch) {
        const level = parseInt(headingMatch[1]);
        const headingMultipliers = [0, 3, 2.5, 2, 1.8, 1.5, 1.3];
        multiplier *= headingMultipliers[level] || 2;
      }
      if (/^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmedText)) {
        multiplier *= 2;
      }
      if (/^[-*+•]/.test(trimmedText)) {
        multiplier *= 1.8;
      }
      if (/[.!?;:]$/.test(word)) {
        multiplier *= this.settings.micropausePunctuation;
      } else if (/[,]$/.test(word)) {
        multiplier *= Math.max(1, this.settings.micropausePunctuation - 0.3);
      }
      if (word.length > 8) {
        multiplier *= this.settings.micropauseLongWords;
      }
      if (word.includes("\n")) {
        multiplier *= this.settings.micropauseParagraph;
      }
      totalTimeMs += baseDelay * multiplier;
    }
    return Math.ceil(totalTimeMs / 1e3);
  }
  getRemainingWords() {
    return Math.max(0, this.words.length - this.currentIndex);
  }
  getElapsedTime() {
    if (this.startTime === 0)
      return 0;
    const now = this.isPlaying ? Date.now() : this.lastPauseTime || Date.now();
    return Math.floor((now - this.startTime - this.pausedTime) / 1e3);
  }
  getRemainingTime() {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    const currentWpm = this.getCurrentWpm();
    return this.calculateAccurateRemainingTime(currentWpm);
  }
  getCurrentWpmPublic() {
    return this.getCurrentWpm();
  }
};

// src/markdown-parser.ts
var MarkdownParser = class {
  static parseToPlainText(markdown) {
    let text = markdown;
    text = text.replace(/^---[\s\S]*?---\n?/m, "");
    text = text.replace(/```[\w-]*\n?([\s\S]*?)```/g, "$1");
    text = text.replace(/`([^`]+)`/g, "$1");
    text = text.replace(/!\[([^\]]*)\]\([^\)]+\)/g, "");
    text = text.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1");
    text = text.replace(/\[\[([^\]|]+)(\|([^\]]+))?\]\]/g, (match, link, pipe, alias) => {
      return alias || link;
    });
    text = text.replace(/\*\*\*([^\*]+)\*\*\*/g, "$1");
    text = text.replace(/\*\*([^\*]+)\*\*/g, "$1");
    text = text.replace(/__([^_]+)__/g, "$1");
    text = text.replace(/\*([^\*\n]+)\*/g, "$1");
    text = text.replace(/_([^_\n]+)_/g, "$1");
    text = text.replace(/~~([^~]+)~~/g, "$1");
    text = text.replace(/==([^=]+)==/g, "$1");
    text = text.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, content) => {
      const level = hashes.length;
      return `[H${level}]${content}`;
    });
    text = text.replace(/^>\s*\[![\w-]+\].*$/gm, "");
    text = text.replace(/^>\s*/gm, "");
    text = text.replace(/^[\s]*[-*+]\s+/gm, "");
    text = text.replace(/^[\s]*\d+\.\s+/gm, "");
    text = text.replace(/^[\s]*[-*_]{3,}[\s]*$/gm, "");
    text = text.replace(/(?:^|\s)(#[a-zA-Z0-9_/-]+)/g, "");
    text = text.replace(/\[\^[^\]]+\]/g, "");
    text = text.replace(/^\[\^[^\]]+\]:.*$/gm, "");
    text = text.replace(/^---\s*Backlinks?\s*---[\s\S]*$/m, "");
    text = text.replace(/^##?\s*Backlinks?[\s\S]*$/m, "");
    text = text.replace(/<!--[\s\S]*?-->/g, "");
    text = text.replace(/<[^>]+>/g, "");
    text = text.replace(/\n{3,}/g, "\n\n");
    text = text.replace(/^[ \t]+/gm, "");
    text = text.replace(/[ \t]+$/gm, "");
    text = text.trim();
    return text;
  }
  /**
   * Parse le texte sélectionné en tenant compte du contexte Obsidian
   */
  static parseSelection(text) {
    return this.parseToPlainText(text);
  }
};

// src/view-state.ts
var DEFAULT_VIEW_STATE = {
  wordsRead: 0,
  startTime: 0,
  showingControls: false,
  showingSettings: false,
  showingStats: false,
  currentWpm: 0,
  currentChunkSize: 0,
  currentFontSize: 0,
  isLoading: false
};
var ViewState = class {
  constructor(initialState = {}) {
    this.listeners = /* @__PURE__ */ new Set();
    this.state = { ...DEFAULT_VIEW_STATE, ...initialState };
  }
  /**
   * Get a state value
   */
  get(key) {
    return this.state[key];
  }
  /**
   * Set a state value and notify listeners
   */
  set(key, value) {
    const oldValue = this.state[key];
    if (oldValue === value)
      return;
    this.state[key] = value;
    this.notify(key, value, oldValue);
  }
  /**
   * Update multiple state values at once
   */
  update(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  /**
   * Reset state to defaults
   */
  reset() {
    Object.entries(DEFAULT_VIEW_STATE).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  /**
   * Subscribe to state changes
   */
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  /**
   * Notify all listeners of a state change
   */
  notify(key, value, oldValue) {
    this.listeners.forEach((listener) => {
      try {
        listener(key, value, oldValue);
      } catch (error) {
        console.error("DashReader: Error in state listener", error);
      }
    });
  }
  /**
   * Get all state as a plain object (for debugging)
   */
  getAll() {
    return { ...this.state };
  }
  /**
   * Toggle a boolean state value
   */
  toggle(key) {
    const currentValue = this.get(key);
    if (typeof currentValue === "boolean") {
      this.set(key, !currentValue);
    }
  }
  /**
   * Increment a numeric state value
   */
  increment(key, delta = 1) {
    const currentValue = this.get(key);
    if (typeof currentValue === "number") {
      this.set(key, currentValue + delta);
    }
  }
};

// src/constants.ts
var CSS_CLASSES = {
  // Main container
  container: "dashreader-container",
  // Toggle bar
  toggleBar: "dashreader-toggle-bar",
  toggleBtn: "dashreader-toggle-btn",
  // Display area
  display: "dashreader-display",
  word: "dashreader-word",
  welcome: "dashreader-welcome",
  highlight: "dashreader-highlight",
  // Context
  contextBefore: "dashreader-context-before",
  contextAfter: "dashreader-context-after",
  // Progress
  progressContainer: "dashreader-progress-container",
  progressBar: "dashreader-progress-bar",
  // Controls
  controls: "dashreader-controls",
  controlGroup: "dashreader-control-group",
  controlLabel: "control-label",
  // Settings
  settings: "dashreader-settings",
  settingGroup: "dashreader-setting-group",
  settingLabel: "setting-label",
  settingToggle: "setting-toggle",
  // Stats
  stats: "dashreader-stats",
  statsText: "dashreader-stats-text",
  wpmDisplay: "dashreader-wpm-display",
  // Buttons
  btn: "dashreader-btn",
  playBtn: "play-btn",
  pauseBtn: "pause-btn",
  smallBtn: "small-btn",
  // Value displays
  wpmValue: "wpm-value",
  wpmInlineValue: "wpm-inline-value",
  chunkValue: "chunk-value",
  fontValue: "font-value",
  accelDurationValue: "accel-duration-value",
  accelTargetValue: "accel-target-value",
  // State classes
  hidden: "hidden"
};
var TIMING = {
  autoLoadDelay: 300,
  autoLoadDelayShort: 200,
  autoLoadDelayVeryShort: 50,
  throttleDelay: 150,
  transitionDuration: 300
};
var TEXT_LIMITS = {
  minSelectionLength: 30,
  minContentLength: 50,
  minParsedLength: 10
};
var INCREMENTS = {
  wpm: 25,
  chunkSize: 1,
  fontSize: 4,
  accelDuration: 5
};
var LIMITS = {
  fontSize: { min: 20, max: 120 },
  wpm: { min: 50, max: 1e3 },
  accelDuration: { min: 10, max: 120 }
};
var ICONS = {
  rewind: "\u23EE",
  play: "\u25B6",
  pause: "\u23F8",
  forward: "\u23ED",
  stop: "\u23F9",
  increment: "+",
  decrement: "\u2212",
  settings: "\u2699\uFE0F",
  stats: "\u{1F4CA}",
  file: "\u{1F4C4}",
  celebration: "\u{1F389}",
  book: "\u{1F4D6}"
};
var HEADING_MULTIPLIERS = {
  h1: 2,
  h2: 1.75,
  h3: 1.5,
  h4: 1.25,
  h5: 1.1,
  h6: 1
};

// src/dom-registry.ts
var DOMRegistry = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  /**
   * Register a DOM element by key
   */
  register(key, element) {
    this.elements.set(key, element);
  }
  /**
   * Get a registered DOM element
   */
  get(key) {
    return this.elements.get(key);
  }
  /**
   * Update text content of a registered element
   */
  updateText(key, text) {
    const element = this.elements.get(key);
    if (element) {
      element.setText(String(text));
    }
  }
  /**
   * Update HTML content of a registered element (use with caution - ensure content is escaped)
   */
  updateHTML(key, html) {
    const element = this.elements.get(key);
    if (element) {
      element.innerHTML = html;
    }
  }
  /**
   * Update style property of a registered element
   */
  updateStyle(key, property, value) {
    const element = this.elements.get(key);
    if (element) {
      element.style[property] = value;
    }
  }
  /**
   * Toggle CSS class on a registered element
   * @param force - true to add class, false to remove it
   */
  toggleClass(key, className, force) {
    const element = this.elements.get(key);
    if (element) {
      element.toggleClass(className, force);
    }
  }
  /**
   * Add CSS class to a registered element
   */
  addClass(key, className) {
    const element = this.elements.get(key);
    if (element) {
      element.classList.add(className);
    }
  }
  /**
   * Remove CSS class from a registered element
   */
  removeClass(key, className) {
    const element = this.elements.get(key);
    if (element) {
      element.classList.remove(className);
    }
  }
  /**
   * Empty the content of a registered element
   */
  empty(key) {
    const element = this.elements.get(key);
    if (element) {
      element.empty();
    }
  }
  /**
   * Check if an element is registered
   */
  has(key) {
    return this.elements.has(key);
  }
  /**
   * Clear all registered elements
   */
  clear() {
    this.elements.clear();
  }
  /**
   * Update multiple text elements at once
   */
  updateMultipleText(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      if (value !== void 0) {
        this.updateText(key, value);
      }
    });
  }
  /**
   * Toggle visibility of multiple elements
   */
  toggleMultipleVisibility(toggles) {
    Object.entries(toggles).forEach(([key, visible]) => {
      if (typeof visible === "boolean") {
        this.toggleClass(key, CSS_CLASSES.hidden, !visible);
      }
    });
  }
};

// src/ui-builders.ts
function createButton(parent, config) {
  const className = config.className ? `${CSS_CLASSES.btn} ${config.className}` : CSS_CLASSES.btn;
  const btn = parent.createEl("button", {
    text: config.icon,
    cls: className,
    attr: { title: config.title }
  });
  btn.addEventListener("click", config.onClick);
  return btn;
}
function createNumberControl(parent, config, registry) {
  const container = parent.createDiv({ cls: CSS_CLASSES.controlGroup });
  container.createEl("span", {
    text: config.label,
    cls: CSS_CLASSES.controlLabel
  });
  createButton(container, {
    icon: config.decrementIcon || ICONS.decrement,
    title: config.decrementTitle || `Decrease (${config.increment || 1})`,
    onClick: config.onDecrement,
    className: CSS_CLASSES.smallBtn
  });
  const valueEl = container.createEl("span", {
    text: String(config.value),
    cls: config.registryKey || "value-display"
  });
  if (config.registryKey && registry) {
    registry.register(config.registryKey, valueEl);
  }
  createButton(container, {
    icon: config.incrementIcon || ICONS.increment,
    title: config.incrementTitle || `Increase (+${config.increment || 1})`,
    onClick: config.onIncrement,
    className: CSS_CLASSES.smallBtn
  });
  return { container, valueEl };
}
function createToggleControl(parent, config) {
  const container = parent.createDiv({ cls: CSS_CLASSES.settingGroup });
  const toggle = container.createEl("label", { cls: CSS_CLASSES.settingToggle });
  const checkbox = toggle.createEl("input", { type: "checkbox" });
  checkbox.checked = config.checked;
  checkbox.addEventListener("change", () => {
    config.onChange(checkbox.checked);
  });
  toggle.createEl("span", { text: ` ${config.label}` });
  return { container, checkbox };
}
function createPlayPauseButtons(parent, onPlay, onPause, registry) {
  const playBtn = createButton(parent, {
    icon: ICONS.play,
    title: "Play (Shift+Space)",
    onClick: onPlay,
    className: CSS_CLASSES.playBtn
  });
  const pauseBtn = createButton(parent, {
    icon: ICONS.pause,
    title: "Pause (Shift+Space)",
    onClick: onPause,
    className: `${CSS_CLASSES.pauseBtn} ${CSS_CLASSES.hidden}`
  });
  registry.register("playBtn", playBtn);
  registry.register("pauseBtn", pauseBtn);
}
function updatePlayPauseButtons(registry, isPlaying) {
  registry.toggleClass("playBtn", CSS_CLASSES.hidden, isPlaying);
  registry.toggleClass("pauseBtn", CSS_CLASSES.hidden, !isPlaying);
}
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}
function escapeHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function createWelcomeMessage() {
  return `
    <div style="font-size: 20px; color: var(--text-muted); text-align: center;">
      <div style="margin-bottom: 12px;">${ICONS.book} Select text to start reading</div>
      <div style="font-size: 14px; opacity: 0.7;">or use Cmd+P \u2192 "Read selected text"</div>
    </div>
  `;
}
function createReadyMessage(wordsToRead, totalWords, startIndex, durationText, sourceInfo = "") {
  const startInfo = startIndex !== void 0 && startIndex > 0 ? ` <span style="opacity: 0.6;">(starting at word ${startIndex + 1}/${totalWords})</span>` : "";
  return `
    <div style="font-size: 18px; color: var(--text-muted); text-align: center;">
      ${sourceInfo}
      Ready to read ${wordsToRead} words${startInfo}<br/>
      <span style="font-size: 14px; opacity: 0.7;">Estimated time: ~${durationText}</span><br/>
      <span style="font-size: 14px; opacity: 0.7;">Press Shift+Space to start</span>
    </div>
  `;
}

// src/auto-load-manager.ts
var import_obsidian = require("obsidian");
function isNavigationKey(evt) {
  return (
    // Arrow keys
    evt.key === "ArrowUp" || evt.key === "ArrowDown" || evt.key === "ArrowLeft" || evt.key === "ArrowRight" || // Home/End/PageUp/PageDown
    evt.key === "Home" || evt.key === "End" || evt.key === "PageUp" || evt.key === "PageDown" || // Enter
    evt.key === "Enter" || // Vim-style navigation
    evt.key === "j" && evt.ctrlKey || evt.key === "k" && evt.ctrlKey || evt.key === "d" && evt.ctrlKey || evt.key === "u" && evt.ctrlKey || // Cmd/Ctrl + arrows
    (evt.key === "ArrowUp" || evt.key === "ArrowDown") && (evt.metaKey || evt.ctrlKey)
  );
}
function isSelectionKey(evt) {
  return evt.shiftKey || evt.key === "a" && (evt.metaKey || evt.ctrlKey);
}
function extractEditorContent(app) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (!activeView) {
    return { activeView: null, currentFile: null };
  }
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile) {
    return { activeView, currentFile: null };
  }
  const fileName = currentFile.name;
  const editor = activeView.editor;
  let selection;
  let lineNumber;
  if (editor.somethingSelected()) {
    selection = editor.getSelection();
    const cursor2 = editor.getCursor("from");
    lineNumber = cursor2.line + 1;
  }
  const fullContent = editor.getValue();
  const cursor = editor.getCursor();
  const cursorPosition = editor.posToOffset(cursor);
  return {
    activeView,
    currentFile,
    fileName,
    selection,
    fullContent,
    cursorPosition,
    lineNumber
  };
}
var AutoLoadManager = class {
  constructor(app, loadTextCallback, isViewShown) {
    this.app = app;
    this.loadTextCallback = loadTextCallback;
    this.isViewShown = isViewShown;
    this.state = {
      lastSelection: "",
      lastFilePath: "",
      lastCursorPosition: -1,
      lastCheckTime: 0
    };
  }
  /**
   * Check for selection or cursor changes and load text if needed
   * Includes throttling to avoid excessive checks
   */
  checkSelectionOrCursor() {
    const now = Date.now();
    if (now - this.state.lastCheckTime < TIMING.throttleDelay) {
      return;
    }
    this.state.lastCheckTime = now;
    const content = extractEditorContent(this.app);
    if (!content.activeView || !content.currentFile) {
      return;
    }
    if (content.selection && content.selection.length > TEXT_LIMITS.minSelectionLength) {
      if (content.selection !== this.state.lastSelection) {
        this.state.lastSelection = content.selection;
        console.log(
          "DashReader: Auto-loading selection",
          content.selection.length,
          "characters from",
          content.fileName,
          "line",
          content.lineNumber
        );
        this.loadTextCallback(content.selection, {
          fileName: content.fileName,
          lineNumber: content.lineNumber
        });
      }
      return;
    }
    if (content.fullContent && content.fullContent.trim().length > TEXT_LIMITS.minContentLength) {
      if (content.cursorPosition !== this.state.lastCursorPosition) {
        const positionDiff = Math.abs(content.cursorPosition - this.state.lastCursorPosition);
        console.log(
          "DashReader: Cursor moved from",
          this.state.lastCursorPosition,
          "to",
          content.cursorPosition,
          "(diff:",
          positionDiff,
          ")"
        );
        console.log(
          "DashReader: Reloading from cursor position",
          content.cursorPosition,
          "in",
          content.fileName
        );
        this.loadTextCallback(content.fullContent, {
          fileName: content.fileName,
          cursorPosition: content.cursorPosition
        });
        this.state.lastSelection = "";
        this.state.lastCursorPosition = content.cursorPosition;
      }
    }
  }
  /**
   * Load content from the active editor
   * Used by file-open and leaf-change events
   */
  loadFromEditor(delay = TIMING.autoLoadDelay) {
    setTimeout(() => {
      if (!this.isViewShown())
        return;
      const content = extractEditorContent(this.app);
      if (!content.activeView || !content.currentFile)
        return;
      if (content.selection && content.selection.length > TEXT_LIMITS.minSelectionLength) {
        console.log(
          "DashReader: Auto-loading selection",
          content.selection.length,
          "characters from line",
          content.lineNumber
        );
        this.loadTextCallback(content.selection, {
          fileName: content.fileName,
          lineNumber: content.lineNumber
        });
        return;
      }
      if (content.fullContent && content.fullContent.trim().length > TEXT_LIMITS.minContentLength) {
        console.log("DashReader: Auto-loading entire page from cursor position", content.cursorPosition);
        this.loadTextCallback(content.fullContent, {
          fileName: content.fileName,
          cursorPosition: content.cursorPosition
        });
      }
    }, delay);
  }
  /**
   * Reset tracking state for a new file
   */
  resetForNewFile(filePath) {
    this.state.lastSelection = "";
    this.state.lastFilePath = filePath;
    this.state.lastCursorPosition = -1;
  }
  /**
   * Check if the file has changed
   */
  hasFileChanged(filePath) {
    return filePath !== this.state.lastFilePath;
  }
  /**
   * Get current state (for debugging)
   */
  getState() {
    return { ...this.state };
  }
};

// src/rsvp-view.ts
var VIEW_TYPE_DASHREADER = "dashreader-view";
var DashReaderView = class extends import_obsidian2.ItemView {
  // ──────────────────────────────────────────────────────────────────────
  // Constructor
  // ──────────────────────────────────────────────────────────────────────
  /**
   * Creates a new DashReaderView instance
   *
   * @param leaf - Obsidian workspace leaf to attach to
   * @param settings - Plugin settings
   */
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
    this.state = new ViewState({
      currentWpm: settings.wpm,
      currentChunkSize: settings.chunkSize,
      currentFontSize: settings.fontSize
    });
    this.dom = new DOMRegistry();
    this.engine = new RSVPEngine(
      settings,
      this.onWordChange.bind(this),
      this.onComplete.bind(this)
    );
    this.autoLoadManager = new AutoLoadManager(
      this.app,
      this.loadText.bind(this),
      () => {
        var _a, _b;
        return (_b = (_a = this.mainContainerEl) == null ? void 0 : _a.isShown()) != null ? _b : false;
      }
    );
  }
  // ──────────────────────────────────────────────────────────────────────
  // Obsidian View Lifecycle
  // ──────────────────────────────────────────────────────────────────────
  /**
   * Returns the unique view type identifier
   * @returns View type string
   */
  getViewType() {
    return VIEW_TYPE_DASHREADER;
  }
  /**
   * Returns the display name shown in Obsidian UI
   * @returns Display name
   */
  getDisplayText() {
    return "DashReader";
  }
  /**
   * Returns the icon identifier for this view
   * @returns Icon name
   */
  getIcon() {
    return "zap";
  }
  /**
   * Called when the view is opened
   * Builds UI, sets up hotkeys, and registers auto-load
   */
  async onOpen() {
    this.mainContainerEl = this.contentEl.createDiv({ cls: CSS_CLASSES.container });
    this.buildUI();
    this.setupHotkeys();
    this.app.workspace.onLayoutReady(() => {
      this.setupAutoLoad();
    });
  }
  /**
   * Called when the view is closed
   * Stops reading and cleans up resources
   */
  async onClose() {
    this.engine.stop();
    this.dom.clear();
  }
  // ============================================================================
  // SECTION 3: UI CONSTRUCTION
  // ============================================================================
  /**
   * Orchestrates the construction of all UI components
   * Called once during view initialization
   *
   * Order matters: toggle bar, stats, display, progress, controls, settings
   */
  buildUI() {
    this.buildToggleBar();
    this.buildStats();
    this.buildDisplayArea();
    this.buildProgressBar();
    this.buildControls();
    this.buildInlineSettings();
  }
  /**
   * Builds the toggle bar with settings and stats buttons
   * Located at the top of the view
   */
  buildToggleBar() {
    this.toggleBar = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.toggleBar });
    createButton(this.toggleBar, {
      icon: ICONS.settings,
      title: "Toggle controls (C)",
      onClick: () => this.togglePanel("controls"),
      className: CSS_CLASSES.toggleBtn
    });
    createButton(this.toggleBar, {
      icon: ICONS.stats,
      title: "Toggle stats (S)",
      onClick: () => this.togglePanel("stats"),
      className: CSS_CLASSES.toggleBtn
    });
  }
  /**
   * Builds the statistics display panel
   * Shows WPM, words read, time elapsed, etc.
   */
  buildStats() {
    this.statsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.stats} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("statsEl", this.statsEl);
    const wpmDisplay = this.statsEl.createDiv({ cls: CSS_CLASSES.wpmDisplay });
    wpmDisplay.setText(`${this.settings.wpm} WPM`);
    this.dom.register("wpmDisplay", wpmDisplay);
    const statsText = this.statsEl.createDiv({ cls: CSS_CLASSES.statsText });
    statsText.setText("Ready");
    this.dom.register("statsText", statsText);
  }
  /**
   * Builds the main display area for word presentation
   * Includes context before/after if enabled
   */
  buildDisplayArea() {
    const displayArea = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.display });
    if (this.settings.showContext) {
      this.contextBeforeEl = displayArea.createDiv({ cls: CSS_CLASSES.contextBefore });
      this.dom.register("contextBeforeEl", this.contextBeforeEl);
    }
    this.wordEl = displayArea.createDiv({ cls: CSS_CLASSES.word });
    this.wordEl.style.fontSize = `${this.settings.fontSize}px`;
    this.wordEl.style.fontFamily = this.settings.fontFamily;
    this.wordEl.style.color = this.settings.fontColor;
    this.wordEl.innerHTML = createWelcomeMessage();
    this.dom.register("wordEl", this.wordEl);
    if (this.settings.showContext) {
      this.contextAfterEl = displayArea.createDiv({ cls: CSS_CLASSES.contextAfter });
      this.dom.register("contextAfterEl", this.contextAfterEl);
    }
  }
  /**
   * Builds the progress bar at the bottom of display
   * Updates during reading to show progress
   */
  buildProgressBar() {
    this.progressEl = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.progressContainer });
    const progressBar = this.progressEl.createDiv({ cls: CSS_CLASSES.progressBar });
    progressBar.style.width = "0%";
    progressBar.style.background = this.settings.highlightColor;
    this.dom.register("progressBar", progressBar);
  }
  /**
   * Builds the playback controls panel
   * Includes play/pause, rewind, forward, stop, WPM, and chunk size controls
   */
  buildControls() {
    this.controlsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.controls} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("controlsEl", this.controlsEl);
    const playControls = this.controlsEl.createDiv({ cls: CSS_CLASSES.controlGroup });
    createButton(playControls, {
      icon: ICONS.rewind,
      title: "Rewind (\u2190)",
      onClick: () => this.engine.rewind()
    });
    createPlayPauseButtons(playControls, () => this.togglePlay(), () => this.engine.pause(), this.dom);
    createButton(playControls, {
      icon: ICONS.forward,
      title: "Forward (\u2192)",
      onClick: () => this.engine.forward()
    });
    createButton(playControls, {
      icon: ICONS.stop,
      title: "Stop (Esc)",
      onClick: () => this.engine.reset()
    });
    createNumberControl(
      this.controlsEl,
      {
        label: "WPM: ",
        value: this.settings.wpm,
        onIncrement: () => this.changeValue("wpm", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("wpm", -INCREMENTS.wpm),
        increment: INCREMENTS.wpm,
        registryKey: "wpmValue"
      },
      this.dom
    );
    createNumberControl(
      this.controlsEl,
      {
        label: "Words: ",
        value: this.settings.chunkSize,
        onIncrement: () => this.changeValue("chunkSize", INCREMENTS.chunkSize),
        onDecrement: () => this.changeValue("chunkSize", -INCREMENTS.chunkSize),
        registryKey: "chunkValue"
      },
      this.dom
    );
  }
  /**
   * Builds the inline settings panel
   * Allows quick adjustments to WPM, acceleration, font size, etc.
   */
  buildInlineSettings() {
    this.settingsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.settings} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("settingsEl", this.settingsEl);
    createNumberControl(
      this.settingsEl,
      {
        label: "Speed (WPM): ",
        value: this.settings.wpm,
        onIncrement: () => this.changeValue("wpm", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("wpm", -INCREMENTS.wpm),
        increment: INCREMENTS.wpm,
        registryKey: "wpmInlineValue",
        decrementTitle: "Slower (-25)",
        incrementTitle: "Faster (+25)"
      },
      this.dom
    );
    createToggleControl(this.settingsEl, {
      label: "Speed Acceleration",
      checked: this.settings.enableAcceleration,
      onChange: (checked) => {
        this.settings.enableAcceleration = checked;
        this.engine.updateSettings(this.settings);
        this.accelDurationGroup.style.display = checked ? "flex" : "none";
        this.accelTargetGroup.style.display = checked ? "flex" : "none";
      }
    });
    const accelDurationControl = createNumberControl(
      this.settingsEl,
      {
        label: "Accel Duration (s): ",
        value: this.settings.accelerationDuration,
        onIncrement: () => this.changeValue("accelDuration", INCREMENTS.accelDuration),
        onDecrement: () => this.changeValue("accelDuration", -INCREMENTS.accelDuration),
        registryKey: "accelDurationValue",
        decrementTitle: "Shorter (-5s)",
        incrementTitle: "Longer (+5s)"
      },
      this.dom
    );
    this.accelDurationGroup = accelDurationControl.container;
    this.accelDurationGroup.style.display = this.settings.enableAcceleration ? "flex" : "none";
    const accelTargetControl = createNumberControl(
      this.settingsEl,
      {
        label: "Target WPM: ",
        value: this.settings.accelerationTargetWpm,
        onIncrement: () => this.changeValue("accelTarget", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("accelTarget", -INCREMENTS.wpm),
        registryKey: "accelTargetValue",
        decrementTitle: "Lower (-25)",
        incrementTitle: "Higher (+25)"
      },
      this.dom
    );
    this.accelTargetGroup = accelTargetControl.container;
    this.accelTargetGroup.style.display = this.settings.enableAcceleration ? "flex" : "none";
    createNumberControl(
      this.settingsEl,
      {
        label: "Font Size: ",
        value: this.settings.fontSize,
        onIncrement: () => this.changeValue("fontSize", INCREMENTS.fontSize),
        onDecrement: () => this.changeValue("fontSize", -INCREMENTS.fontSize),
        registryKey: "fontValue",
        decrementTitle: "Smaller",
        incrementTitle: "Larger"
      },
      this.dom
    );
    createToggleControl(this.settingsEl, {
      label: "Show context",
      checked: this.settings.showContext,
      onChange: (checked) => {
        this.settings.showContext = checked;
        this.toggleContextDisplay();
      }
    });
    createToggleControl(this.settingsEl, {
      label: "Micropause",
      checked: this.settings.enableMicropause,
      onChange: (checked) => {
        this.settings.enableMicropause = checked;
        this.engine.updateSettings(this.settings);
      }
    });
  }
  // ============================================================================
  // SECTION 4: USER INTERACTIONS
  // ============================================================================
  /**
   * Unified value change handler
   * Replaces 5 separate change functions (changeWpm, changeWpmInline, etc.)
   *
   * @param type - Type of value to change
   * @param delta - Amount to change (positive or negative)
   */
  changeValue(type, delta) {
    switch (type) {
      case "wpm": {
        const newWpm = this.engine.getWpm() + delta;
        this.engine.setWpm(newWpm);
        this.settings.wpm = this.engine.getWpm();
        this.state.set("currentWpm", this.settings.wpm);
        this.dom.updateMultipleText({
          wpmDisplay: `${this.settings.wpm} WPM`,
          wpmValue: String(this.settings.wpm),
          wpmInlineValue: String(this.settings.wpm)
        });
        break;
      }
      case "chunkSize": {
        const newSize = this.engine.getChunkSize() + delta;
        this.engine.setChunkSize(newSize);
        this.settings.chunkSize = this.engine.getChunkSize();
        this.state.set("currentChunkSize", this.settings.chunkSize);
        this.dom.updateText("chunkValue", this.settings.chunkSize);
        break;
      }
      case "fontSize": {
        const newSize = Math.max(
          LIMITS.fontSize.min,
          Math.min(LIMITS.fontSize.max, this.settings.fontSize + delta)
        );
        this.settings.fontSize = newSize;
        this.state.set("currentFontSize", newSize);
        this.wordEl.style.fontSize = `${newSize}px`;
        this.dom.updateText("fontValue", newSize);
        break;
      }
      case "accelDuration": {
        const newDuration = Math.max(
          LIMITS.accelDuration.min,
          Math.min(LIMITS.accelDuration.max, this.settings.accelerationDuration + delta)
        );
        this.settings.accelerationDuration = newDuration;
        this.engine.updateSettings(this.settings);
        this.dom.updateText("accelDurationValue", newDuration);
        break;
      }
      case "accelTarget": {
        const newTarget = Math.max(
          LIMITS.wpm.min,
          Math.min(LIMITS.wpm.max, this.settings.accelerationTargetWpm + delta)
        );
        this.settings.accelerationTargetWpm = newTarget;
        this.engine.updateSettings(this.settings);
        this.dom.updateText("accelTargetValue", newTarget);
        break;
      }
    }
  }
  /**
   * Unified panel toggle handler
   * Replaces 3 separate toggle functions (toggleControls, toggleStats, etc.)
   *
   * @param panel - Panel to toggle ('controls' or 'stats')
   */
  togglePanel(panel) {
    if (panel === "controls") {
      this.state.toggle("showingControls");
      const showing = this.state.get("showingControls");
      this.controlsEl.toggleClass(CSS_CLASSES.hidden, !showing);
      this.settingsEl.toggleClass(CSS_CLASSES.hidden, !showing);
    } else if (panel === "stats") {
      this.state.toggle("showingStats");
      const showing = this.state.get("showingStats");
      this.statsEl.toggleClass(CSS_CLASSES.hidden, !showing);
    }
  }
  /**
   * Toggles the visibility of context before/after current word
   */
  toggleContextDisplay() {
    const display = this.settings.showContext ? "block" : "none";
    if (this.contextBeforeEl) {
      this.contextBeforeEl.style.display = display;
    }
    if (this.contextAfterEl) {
      this.contextAfterEl.style.display = display;
    }
  }
  // ============================================================================
  // SECTION 5: AUTO-LOAD SYSTEM
  // ============================================================================
  /**
   * Sets up automatic text loading from editor
   *
   * Registers event handlers for:
   * - file-open: Load text when opening a file
   * - active-leaf-change: Load text when switching files
   * - mouseup: Check for selection/cursor changes
   * - keyup: Check for navigation/selection keys
   *
   * Actual tracking logic is encapsulated in AutoLoadManager
   */
  setupAutoLoad() {
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (!file)
          return;
        this.autoLoadManager.resetForNewFile(file.path);
        console.log("DashReader: File opened:", file.path);
        this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelay);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        if (!this.mainContainerEl || !this.mainContainerEl.isShown())
          return;
        console.log("DashReader: Active leaf changed");
        const currentFile = this.app.workspace.getActiveFile();
        if (currentFile && this.autoLoadManager.hasFileChanged(currentFile.path)) {
          this.autoLoadManager.resetForNewFile(currentFile.path);
          this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelayShort);
        }
      })
    );
    this.registerDomEvent(document, "mouseup", () => {
      console.log("DashReader: Mouse click detected");
      setTimeout(() => {
        if (this.mainContainerEl.isShown()) {
          this.autoLoadManager.checkSelectionOrCursor();
        }
      }, TIMING.autoLoadDelayVeryShort);
    });
    this.registerDomEvent(document, "keyup", (evt) => {
      if (isNavigationKey(evt) || isSelectionKey(evt)) {
        console.log("DashReader: Navigation key detected:", evt.key, "with modifiers:", {
          shift: evt.shiftKey,
          ctrl: evt.ctrlKey,
          meta: evt.metaKey
        });
        setTimeout(() => {
          if (this.mainContainerEl.isShown()) {
            this.autoLoadManager.checkSelectionOrCursor();
          }
        }, TIMING.autoLoadDelayVeryShort);
      }
    });
    console.log("DashReader: Auto-load setup complete");
  }
  // ============================================================================
  // SECTION 6: HOTKEYS & KEYBOARD
  // ============================================================================
  /**
   * Sets up keyboard shortcuts for playback control
   */
  setupHotkeys() {
    document.addEventListener("keydown", this.handleKeyPress.bind(this));
  }
  /**
   * Handles keyboard shortcuts
   *
   * Shortcuts:
   * - C: Toggle controls (when not playing)
   * - S: Toggle stats (when not playing)
   * - Shift+Space: Play/Pause
   * - Arrow keys: Rewind/Forward, WPM adjustment
   * - Escape: Stop reading
   *
   * @param e - Keyboard event
   */
  handleKeyPress(e) {
    if (!this.mainContainerEl.isShown())
      return;
    if (e.key === "c" && !this.engine.getIsPlaying()) {
      e.preventDefault();
      this.togglePanel("controls");
      return;
    }
    if (e.key === "s" && !this.engine.getIsPlaying()) {
      e.preventDefault();
      this.togglePanel("stats");
      return;
    }
    const keyCode = e.code || e.key;
    if (keyCode === "Space" && e.shiftKey) {
      e.preventDefault();
      console.log("DashReader: Shift+Space pressed, toggling play");
      this.togglePlay();
      return;
    }
    switch (keyCode) {
      case this.settings.hotkeyRewind:
        e.preventDefault();
        this.engine.rewind();
        break;
      case this.settings.hotkeyForward:
        e.preventDefault();
        this.engine.forward();
        break;
      case this.settings.hotkeyIncrementWpm:
        e.preventDefault();
        this.changeValue("wpm", INCREMENTS.wpm);
        break;
      case this.settings.hotkeyDecrementWpm:
        e.preventDefault();
        this.changeValue("wpm", -INCREMENTS.wpm);
        break;
      case this.settings.hotkeyQuit:
        e.preventDefault();
        this.engine.stop();
        break;
    }
  }
  /**
   * Toggles play/pause state
   * Updates UI buttons accordingly
   */
  togglePlay() {
    if (this.engine.getIsPlaying()) {
      this.engine.pause();
      updatePlayPauseButtons(this.dom, false);
    } else {
      if (this.state.get("startTime") === 0) {
        this.state.set("startTime", Date.now());
      }
      this.engine.play();
      updatePlayPauseButtons(this.dom, true);
    }
  }
  // ============================================================================
  // SECTION 7: READING ENGINE CALLBACKS
  // ============================================================================
  /**
   * Called by engine when a new word is displayed
   * Updates the UI with the current word, context, progress, and stats
   *
   * @param chunk - Word chunk with text, index, delay info
   */
  onWordChange(chunk) {
    const headingMatch = chunk.text.match(/^\[H(\d)\]/);
    let displayText = chunk.text;
    let headingLevel = 0;
    let showSeparator = false;
    if (headingMatch) {
      headingLevel = parseInt(headingMatch[1]);
      displayText = chunk.text.replace(/^\[H\d\]/, "");
      showSeparator = true;
      console.log("DashReader: Heading detected - Level", headingLevel, "Text:", displayText);
    }
    this.displayWordWithHeading(displayText, headingLevel, showSeparator);
    if (this.settings.showContext && this.contextBeforeEl && this.contextAfterEl) {
      const context = this.engine.getContext(this.settings.contextWords);
      this.contextBeforeEl.setText(context.before.join(" "));
      this.contextAfterEl.setText(context.after.join(" "));
    }
    const progress = this.engine.getProgress();
    this.dom.updateStyle("progressBar", "width", `${progress}%`);
    this.state.increment("wordsRead");
    this.updateStats();
  }
  /**
   * Displays a word with heading-based font size adjustment
   *
   * @param word - Word to display
   * @param headingLevel - Heading level (1-6) or 0 for normal text
   * @param showSeparator - Whether to show separator line before heading
   */
  displayWordWithHeading(word, headingLevel, showSeparator = false) {
    let fontSizeMultiplier = 1;
    if (headingLevel > 0) {
      const multipliers = [
        0,
        HEADING_MULTIPLIERS.h1,
        HEADING_MULTIPLIERS.h2,
        HEADING_MULTIPLIERS.h3,
        HEADING_MULTIPLIERS.h4,
        HEADING_MULTIPLIERS.h5,
        HEADING_MULTIPLIERS.h6
      ];
      fontSizeMultiplier = multipliers[headingLevel] || 1;
    }
    const adjustedFontSize = this.settings.fontSize * fontSizeMultiplier;
    const processedWord = this.processWord(word);
    const separator = showSeparator ? `<div style="width: 60%; height: 2px; background: var(--text-muted); opacity: 0.4; margin: 0 auto 20px auto;"></div>` : "";
    this.wordEl.innerHTML = `
      ${separator}
      <div style="font-size: ${adjustedFontSize}px; transition: font-size 0.3s ease; font-weight: ${headingLevel > 0 ? "bold" : "normal"};">
        ${processedWord}
      </div>
    `;
  }
  /**
   * Processes a word for display with center character highlighting
   * Escapes HTML to prevent XSS attacks
   *
   * @param word - Word to process
   * @returns HTML string with highlighted center character
   */
  processWord(word) {
    const cleanWord = word.trim();
    const center = Math.max(Math.floor(cleanWord.length / 2) - 1, 0);
    let result = "";
    for (let i = 0; i < cleanWord.length; i++) {
      const escapedChar = escapeHtml(cleanWord[i]);
      if (i === center) {
        result += `<span class="${CSS_CLASSES.highlight}" style="color: ${this.settings.highlightColor}">${escapedChar}</span>`;
      } else {
        result += escapedChar;
      }
    }
    return result;
  }
  /**
   * Called by engine when reading is complete
   * Updates UI to show completion message
   */
  onComplete() {
    updatePlayPauseButtons(this.dom, false);
    this.dom.updateText("statsText", `Completed! ${ICONS.celebration}`);
  }
  /**
   * Updates the stats display with current reading statistics
   * Shows: words read, elapsed time, current WPM, remaining time
   */
  updateStats() {
    const elapsed = this.engine.getElapsedTime();
    const currentWpm = this.engine.getCurrentWpmPublic();
    const remaining = this.engine.getRemainingTime();
    const wordsRead = this.state.get("wordsRead");
    this.dom.updateText(
      "statsText",
      `${wordsRead}/${this.engine.getTotalWords()} words | ${formatTime(elapsed)} | ${currentWpm} WPM | ${formatTime(remaining)} left`
    );
  }
  // ============================================================================
  // SECTION 8: TEXT LOADING
  // ============================================================================
  /**
   * Loads text for reading
   *
   * Process:
   * 1. Stop current reading if playing
   * 2. Parse markdown to plain text
   * 3. Calculate word index from cursor position (if provided)
   * 4. Validate text length
   * 5. Load into engine
   * 6. Update UI with ready message
   * 7. Auto-start if enabled
   *
   * @param text - Text to load (raw markdown)
   * @param source - Optional source information (filename, line, cursor position)
   */
  loadText(text, source) {
    console.log("DashReader: loadText called with source:", source);
    if (this.engine.getIsPlaying()) {
      this.engine.stop();
      updatePlayPauseButtons(this.dom, false);
      console.log("DashReader: Stopped current reading");
    }
    console.log("DashReader: Parsing markdown, original length:", text.length);
    const plainText = MarkdownParser.parseToPlainText(text);
    console.log("DashReader: After parsing, length:", plainText.length);
    console.log("DashReader: First 100 chars:", plainText.substring(0, 100));
    let wordIndexFromCursor;
    if ((source == null ? void 0 : source.cursorPosition) !== void 0) {
      console.log("DashReader: Cursor position detected:", source.cursorPosition);
      const textUpToCursor = text.substring(0, source.cursorPosition);
      const parsedUpToCursor = MarkdownParser.parseToPlainText(textUpToCursor);
      const wordsBeforeCursor = parsedUpToCursor.trim().split(/\s+/).filter((w) => w.length > 0);
      wordIndexFromCursor = wordsBeforeCursor.length;
      console.log("DashReader: Original text up to cursor:", textUpToCursor.length, "chars");
      console.log("DashReader: Parsed text up to cursor:", parsedUpToCursor.length, "chars");
      console.log("DashReader: Words before cursor (after parsing):", wordsBeforeCursor.slice(0, 10), "...");
      console.log("DashReader: Cursor at character", source.cursorPosition, "\u2192 word index", wordIndexFromCursor, "(in parsed text)");
    } else {
      console.log("DashReader: No cursor position provided");
    }
    if (!plainText || plainText.trim().length < TEXT_LIMITS.minParsedLength) {
      console.log("DashReader: Text too short after parsing");
      return;
    }
    this.engine.setText(plainText, void 0, wordIndexFromCursor);
    this.state.update({ wordsRead: 0, startTime: 0 });
    const welcomeMsg = this.wordEl.querySelector(`.${CSS_CLASSES.welcome}`);
    if (welcomeMsg) {
      welcomeMsg.remove();
    }
    this.wordEl.empty();
    let sourceInfo = "";
    if (source == null ? void 0 : source.fileName) {
      const escapedFileName = escapeHtml(source.fileName);
      const lineInfo = source.lineNumber ? ` (line ${source.lineNumber})` : "";
      sourceInfo = `<div style="font-size: 14px; opacity: 0.6; margin-bottom: 8px;">
        ${ICONS.file} ${escapedFileName}${lineInfo}
      </div>`;
    }
    const totalWords = this.engine.getTotalWords();
    const remainingWords = this.engine.getRemainingWords();
    const estimatedDuration = this.engine.getEstimatedDuration();
    const durationText = formatTime(estimatedDuration);
    const fileInfo = (source == null ? void 0 : source.fileName) ? ` from ${source.fileName}` : "";
    const wordInfo = wordIndexFromCursor && wordIndexFromCursor > 0 ? `${remainingWords}/${totalWords} words` : `${totalWords} words`;
    this.dom.updateText("statsText", `${wordInfo} loaded${fileInfo} - ~${durationText} - Shift+Space to start`);
    this.wordEl.innerHTML = createReadyMessage(remainingWords, totalWords, wordIndexFromCursor, durationText, sourceInfo);
    console.log("DashReader: Words to read:", remainingWords, "out of", totalWords);
    if (this.settings.autoStart) {
      setTimeout(() => {
        this.engine.play();
        updatePlayPauseButtons(this.dom, true);
        this.state.set("startTime", Date.now());
      }, this.settings.autoStartDelay * 1e3);
    }
  }
  // ============================================================================
  // SECTION 9: SETTINGS & LIFECYCLE
  // ============================================================================
  /**
   * Updates settings from plugin settings tab
   * Called when user changes settings in main settings panel
   *
   * @param settings - New settings
   */
  updateSettings(settings) {
    this.settings = settings;
    this.engine.updateSettings(settings);
    if (this.wordEl) {
      this.wordEl.style.fontSize = `${settings.fontSize}px`;
      this.wordEl.style.fontFamily = settings.fontFamily;
      this.wordEl.style.color = settings.fontColor;
    }
    this.dom.updateText("wpmDisplay", `${settings.wpm} WPM`);
  }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DashReaderSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "DashReader Settings" });
    containerEl.createEl("h3", { text: "Reading Settings" });
    new import_obsidian3.Setting(containerEl).setName("Words per minute (WPM)").setDesc("Reading speed (50-1000)").addSlider((slider) => slider.setLimits(50, 1e3, 25).setValue(this.plugin.settings.wpm).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.wpm = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Words at a time").setDesc("Number of words displayed simultaneously (1-5)").addSlider((slider) => slider.setLimits(1, 5, 1).setValue(this.plugin.settings.chunkSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chunkSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Font size").setDesc("Font size in pixels (20-120px)").addSlider((slider) => slider.setLimits(20, 120, 4).setValue(this.plugin.settings.fontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.fontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Font family").setDesc("Font family for text display").addDropdown((dropdown) => dropdown.addOption("inherit", "Default").addOption("monospace", "Monospace").addOption("serif", "Serif").addOption("sans-serif", "Sans-serif").setValue(this.plugin.settings.fontFamily).onChange(async (value) => {
      this.plugin.settings.fontFamily = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Speed Acceleration" });
    new import_obsidian3.Setting(containerEl).setName("Enable acceleration").setDesc("Gradually increase reading speed over time").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAcceleration).onChange(async (value) => {
      this.plugin.settings.enableAcceleration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Acceleration duration").setDesc("Duration to reach target speed (seconds)").addSlider((slider) => slider.setLimits(10, 120, 5).setValue(this.plugin.settings.accelerationDuration).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.accelerationDuration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Target WPM").setDesc("Target reading speed to reach (50-1000)").addSlider((slider) => slider.setLimits(50, 1e3, 25).setValue(this.plugin.settings.accelerationTargetWpm).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.accelerationTargetWpm = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian3.Setting(containerEl).setName("Highlight color").setDesc("Color for the center character highlight").addText((text) => text.setPlaceholder("#4a9eff").setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
      this.plugin.settings.highlightColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Font color").setDesc("Text color").addText((text) => text.setPlaceholder("#ffffff").setValue(this.plugin.settings.fontColor).onChange(async (value) => {
      this.plugin.settings.fontColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Background color").setDesc("Background color").addText((text) => text.setPlaceholder("#1e1e1e").setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
      this.plugin.settings.backgroundColor = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Context Display" });
    new import_obsidian3.Setting(containerEl).setName("Show context").setDesc("Display words before and after current word").addToggle((toggle) => toggle.setValue(this.plugin.settings.showContext).onChange(async (value) => {
      this.plugin.settings.showContext = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Context words").setDesc("Number of context words to display (1-10)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.contextWords).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.contextWords = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Micropause" });
    new import_obsidian3.Setting(containerEl).setName("Enable micropause").setDesc("Automatic pauses based on punctuation and word length").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMicropause).onChange(async (value) => {
      this.plugin.settings.enableMicropause = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Punctuation pause").setDesc("Pause multiplier for punctuation (1.0-3.0)").addSlider((slider) => slider.setLimits(1, 3, 0.1).setValue(this.plugin.settings.micropausePunctuation).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropausePunctuation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Long words pause").setDesc("Pause multiplier for long words (1.0-2.0)").addSlider((slider) => slider.setLimits(1, 2, 0.1).setValue(this.plugin.settings.micropauseLongWords).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropauseLongWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Paragraph pause").setDesc("Pause multiplier for paragraph breaks (1.0-5.0)").addSlider((slider) => slider.setLimits(1, 5, 0.5).setValue(this.plugin.settings.micropauseParagraph).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.micropauseParagraph = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto-start" });
    new import_obsidian3.Setting(containerEl).setName("Auto-start reading").setDesc("Automatically start reading after text loads").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStart).onChange(async (value) => {
      this.plugin.settings.autoStart = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Auto-start delay").setDesc("Delay before auto-start (seconds)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.autoStartDelay).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autoStartDelay = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Display Options" });
    new import_obsidian3.Setting(containerEl).setName("Show progress bar").setDesc("Display reading progress bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showProgress).onChange(async (value) => {
      this.plugin.settings.showProgress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Show statistics").setDesc("Display reading statistics").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStats).onChange(async (value) => {
      this.plugin.settings.showStats = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Keyboard Shortcuts" });
    containerEl.createEl("p", {
      text: "Note: Hotkey customization is available in Obsidian's Hotkeys settings.",
      cls: "setting-item-description"
    });
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  wpm: 300,
  chunkSize: 1,
  fontSize: 48,
  highlightColor: "#4a9eff",
  backgroundColor: "#1e1e1e",
  fontColor: "#ffffff",
  fontFamily: "inherit",
  showContext: true,
  contextWords: 3,
  enableMicropause: true,
  micropausePunctuation: 1.5,
  micropauseLongWords: 1.3,
  micropauseParagraph: 2,
  autoStart: false,
  autoStartDelay: 3,
  showProgress: true,
  showStats: true,
  hotkeyPlay: "Space",
  hotkeyRewind: "ArrowLeft",
  hotkeyForward: "ArrowRight",
  hotkeyIncrementWpm: "ArrowUp",
  hotkeyDecrementWpm: "ArrowDown",
  hotkeyQuit: "Escape",
  enableAcceleration: false,
  accelerationDuration: 30,
  accelerationTargetWpm: 450
};

// main.ts
var DashReaderPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
  }
  async onload() {
    console.log("Loading DashReader plugin");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_DASHREADER,
      (leaf) => {
        this.view = new DashReaderView(leaf, this.settings);
        return this.view;
      }
    );
    this.addRibbonIcon("zap", "Open DashReader", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-dashreader",
      name: "Open DashReader",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "read-selection",
      name: "Read selected text",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.activateView().then(() => {
            if (this.view) {
              this.view.loadText(selection);
            }
          });
        } else {
          new import_obsidian4.Notice("Please select some text first");
        }
      }
    });
    this.addCommand({
      id: "read-note",
      name: "Read entire note",
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (activeView) {
          const content = activeView.editor.getValue();
          this.activateView().then(() => {
            if (this.view) {
              this.view.loadText(content);
            }
          });
        } else {
          new import_obsidian4.Notice("No active note found");
        }
      }
    });
    this.addCommand({
      id: "toggle-play-pause",
      name: "Toggle Play/Pause",
      callback: () => {
        new import_obsidian4.Notice("Use Shift+Space key when DashReader is active");
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Read with DashReader").setIcon("zap").onClick(() => {
              this.activateView().then(() => {
                if (this.view) {
                  this.view.loadText(selection);
                }
              });
            });
          });
        }
      })
    );
    this.addSettingTab(new DashReaderSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.view) {
          this.view.updateSettings(this.settings);
        }
      })
    );
    console.log("DashReader plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading DashReader plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.view) {
      this.view.updateSettings(this.settings);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_DASHREADER);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_DASHREADER,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      this.view = leaf.view;
    }
  }
};
